;;
;; SAL 3.1, Copyright (C) 2006, 2011, SRI International.  All Rights Reserved.
;;
;; SAL is free software; you can redistribute it and/or 
;; modify it under the terms of the GNU General Public License 
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of 
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
;; GNU General Public License for more details. 
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software 
;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
;;

(module sal-esm-engine
        (include "sal.sch")
        (include "fast-hash-table.sch")
        (import sal-esm-state sal-esm-support sal2scm-core sal2scm
                unique-names runtime sal-ast-env sal2scm-runtime
                sal-esm-action iterators sal-expression sal-type gmp-scheme
                sal-pp state-cache state-entry-channel queue compile-and-load
                code-table state-to-do-list sal-context sal-parser-utility
                scm2sal state-entry-channel sal-esm-symmetry sal-ast-for-each
                sal-display-variable-value sal-transition-step
                sal-esm-options sal-module sal-transient-vars sal-decls
                sal2scm-type sal-esm-access-level-table sal-ast-table)
        (export <sal-esm-engine>
                <sal-esm-engine-scm-context>
                *esm-var-vector*
                *esm-deadlock-detected*
                (inline sal-esm-engine/deadlock?)
                (make-sal-esm-engine esm-module sal-scm-ctx property-used-vars)
                (sal-esm-engine-scm-context/init! ctx)
                (make-sal-esm-engine-scm-context)
                (sal-esm-engine-scm-context/compile-code! ctx)
                (sal-esm-engine-scm-context/add-definition! ctx code id-prefix)
                (sal-esm-engine/reset-var-vector! esm-engine)
                (sal-esm-engine/set-curr-memory-layout! esm-engine)
                (sal-esm-engine/set-other-memory-layout! esm-engine)
                (mk-set-curr-state-proc engine)
                (mk-copy-next-state-to-channel-proc engine)
                (mk-copy-curr-state-to-channel-proc engine)
                (mk-copy-selection-vars-to-channel-proc engine)
                (mk-channel-curr-vars-to-assignment-table-proc engine)
                (mk-channel-inputs-to-assignment-table-proc engine)
                (sal-esm-engine/display-curr-state engine)
                (sal-esm-engine/display-next-state engine)
                (sal-esm-engine/display-transition-info engine)
                (sal-esm/display-ce-found-message num-states))
        )

;;
;; Execution Engine:
;;
;; STATE
;; -----
;; 
;; The code generated by the explicit state engine models
;; state variables as global Scheme variables. The value
;; of these variables can be stored into and retrieved from
;; bit streams. Bit streams are a compact representation
;; of a state.
;;
;; * (curr-state->bit-stream bit-stream) set the give bit-stream with
;; the contents of the current state variables.
;;
;; * (bit-stream->curr-state bit-stream) set the current state variables with
;; the contents of the bit-stream.
;;
;; * (next-state->bit-stream bit-stream) set the given bit-stream with
;; the contents of the next state variables 
;;
;; Remark 1: Different bitstreams can be used by this engine. Example: BDD based.
;;
;; Remark 2: Symmetry reduction is implemented by having a specialized
;; code for (curr-state->bit-stream bit-stream) and
;; (next-state->bit-stream bit-stream).  This code normalizes the
;; state when sending it to the bitstream.
;;
;; TRANSITIONS
;; -----------
;;
;; The explicit state execution engine can only execute modules that
;; can execute a finite number of transitions for every state.
;; The execution engine associates an unique index (i.e., number)
;; with each possible transition. This index is a number in the 
;; interval [0..n-1], where n is the number of possible transitions.
;; 
;; The two main procedures generated by the execution engine are
;; next-trans-alt and exec-trans-alt. The function next-trans-alt is
;; used to implement speculative execution.
;;
;; next-trans-alt [0..n-1] --> [0..n-1] U { #f }
;; exec-trans-alt [0..n-1] --> #unspecified
;;
;; * (next-trans-alt idx) returns the next enabled index idx' >=
;; idx.  It returns #f if such index doesn't exist. An index
;; is enabled when all guards in the associated transition
;; are (possibly) enabled. We say possibly enabled because 
;; the guards may use next variables, and these values
;; are not available at the time the procedure is called.
;; Guards that cannot be executed in next-trans-alt are called
;; "delayed" guards. These guards are executed after the
;; the actual execution of the transition.
;;
;; * (exec-trans-alt idx) executes the assignment in the 
;; transition idx. Some assignments may be delayed because
;; the values the depend on are not available.
;;
;; INITIALIZATION
;; --------------
;; 
;; The state initialization procedures are similar to the ones
;; used to perform transitions. 
;;
;; * (next-init-alt idx)
;; * (exec-init-alt idx)
;;
;; Remark: idx is a number in [0..n-1], and n is the number of
;; potential initial states. Guards and assignments can be also
;; delayed. 
;;
;; DELAYED GUARDS AND ASSIGNMENTS
;; ------------------------------
;;
;; * (exec-delayed) -->  {#f, #t, 'error}
;;
;; Execute delayed guards and assignments. Returns #f when one
;; of the guards returns #f. Returns 'error if there is a
;; circular dependency in the code.
;;
;; DETERMINISTIC AND INPUT-INDEPENDENT DEFINED VARIABLES
;; -----------------------------------------------------
;;
;; A variable is said to be defined, if its value is specified in the
;; DEFINITION SECTION. It is deterministic when it is not specified
;; using the IN constructor, and doesn't depend directly or indirectly
;; on other non-deterministic defined variables. It is
;; input-independent when its value doesn't depend directly or
;; indirectly on input variables.  
;;
;; * (eval-det-def) set the value for all deterministic and
;; input-independent defined variables based on the value
;; of the current state variables. 
;;
;; * (eval-det-def-init) this procedure is similar to the previous
;; one, but we do not assume the value of the current variables
;; is available. 
;;
;; NON-DETERMINISTIC OR INPUT-INDEPENDENT DEFINED VARIABLES
;; --------------------------------------------------------
;; 
;; The assignments associated with these variables are moved into
;; the transition section.
;; 
;;
;; INPUT VARIABLES
;; ---------------
;;
;; Suppose a transition system has m possible input values,
;; Then:
;;
;; * (set-input-vars idx) sets the value of the input variables,
;; where idx is a number in [0..m-1], and specify which input
;; value we want.
;;
;; CHOICE VARIABLES
;; ----------------
;; 
;; All other model checkers use a special kind of variable 
;; (choice variables) to track which transition was executed. 
;; The explicit state model checker uses indexes to track
;; the choices. 
;;
;; * (set-choice-vars idx) sets the value of choice variables,
;; where idx is a number in [0..n-1], and n is the number of
;; transitions. The value of non-deterministic defined variables
;; is also set by this procedure. This command assumes that
;; the value of input, deterministic defined, and current state
;; variables is available (i.e., their values are loaded into
;; the respective Scheme global variables). This command
;; is mainly used to produce counterexamples, and it is not
;; used during the search.
;;
;; MONITORS
;; --------
;; 
;; SAL uses monitors to check LTL properties. 
;;
;; * (next-monitor-init-alt idx)
;; * (exec-monitor-init-alt idx)
;; * (next-monitor-trans-alt idx) 
;; * (exec-monitor-trans-alt idx)
;;
;; Remark: Monitors do not delay guards or assignments.
;;
;; SUMMARY: GENERATED PROCEDURES 
;; -----------------------------
;;
;; * (curr-state->bit-stream bit-stream)
;; * (bit-stream->curr-state bit-stream)
;; * (next-state->bit-stream bit-stream)
;; * (next-init-alt idx)
;; * (exec-init-alt idx)
;; * (next-trans-alt idx)
;; * (exec-trans-alt idx)
;; * (exec-delayed)
;; * (eval-det-def)
;; * (eval-det-def-init)
;; * (set-input-vars idx)
;; * (set-choice-vars idx)
;; * (next-monitor-init-alt idx)
;; * (exec-monitor-init-alt idx)
;; * (next-monitor-trans-alt idx) 
;; * (exec-monitor-trans-alt idx)
;;
;; CONSTANTS
;; ---------
;; The following variables store the number of alternatives for the 
;; procedures above:
;; 
;; * num-input-alts
;; * num-init-alts
;; * num-trans-alts
;; * num-monitor-init-alts
;; * num-monitor-trans-alts
;;
;; The number of bits in the input stream is stored in the variable
;;
;; * num-bits
;;
;; VERIFICATION
;; ------------
;;
;; * (check-curr-state)
;; * (check-next-state)
;; * (check-monitor-final-state)
;;
;;
;; GLUING THE PROCEDURES TOGETHER
;; ------------------------------
;;
;; CASE 1) SIMULATION
;;
;; * num-potential-initial-states = num-init-alts
;;
;; * (define (init-engine)
;;      #unspecified)
;;
;; * (define (next-init idx)
;;      (next-init-alt))
;;
;; * (define (exec-init idx)
;;      (exec-init-alt idx)
;;      (eval-det-def-init)
;;      (exec-delayed))
;;
;; * num-potential-successors = num-trans-alts * num-input-alts
;;
;; * (define (set-curr-state bit-stream)
;;     (bit-stream->curr-state bit-stream)
;;     (eval-det-def))
;;
;; * (define (next-trans idx)
;;     (let ((input-idx (/fx idx num-trans-alts)))
;;       (set-input-vars input-idx)
;;       (let ((new-idx (next-trans-alt (remainder idx num-trans-alts))))
;;          (and new-idx
;;               (+fx (*fx input-idx num-trans-alts) new-idx)))))
;;
;; * (define (exec-trans idx)
;;     (exec-trans-alt (remainder idx num-trans-alts))
;;     (exec-delayed))
;;
;; CASE 2) SIMULATION WITH DEADLOCK DETECTION
;;   
;; * num-potential-initial-states = num-init-alts
;;
;; * found-initial?
;; 
;; * (define (init-engine)
;;      (set! found-initial? #f))
;;
;; * (define (next-init idx)
;;      (next-init-alt))
;;
;; * (define (exec-init idx)
;;      (exec-init-alt idx)
;;      (eval-det-def-init)
;;      (let ((result (exec-delayed)))
;;        (when result
;;          (set! found-initial? #t))
;;        result))
;;
;; * num-potential-successors = num-trans-alts * num-input-alts
;;
;; * found-successor?
;; * previous-input-idx
;; * deadlock?
;;
;; * (define (set-curr-state bit-stream)
;;     (bit-stream->curr-state bit-stream)
;;     (eval-det-def)
;;     (set! found-successor? #f)
;;     (set! previous-input-idx 0)
;;     (set! deadlock? #f))
;;
;; * (define (next-trans idx)
;;     (let ((input-idx (/fx idx num-trans-alts)))
;;       (unless (= input-idx previous-input-idx)
;;         (cond
;;          (found-successor?
;;            (set! previous-input-idx input-idx)
;;            (set! found-successor? #f))
;;          (else
;;           (set! deadlock? #t))))
;;       (unless deadlock?
;;         (set-input-vars input-idx)
;;         (let ((new-idx (next-trans-alt (remainder idx num-trans-alts))))
;;            (and new-idx
;;                 (+fx (*fx input-idx num-trans-alts) new-idx)))))))
;;
;; Remark: After calling (next-trans idx) we should check the variable
;; deadlock?, if it is #t, then the system is in deadlock for the input
;; combination stored in previous-input-idx
;;
;; * (define (exec-trans idx)
;;     (exec-trans-alt (remainder idx num-trans-alts))
;;     (and (exec-delayed)
;;          (set! found-successor? #t)
;;          #t))
;; 
;; CASE 3) INVARIANT CHECKING WITH DEADLOCK CHECKING. Invariant uses
;; only state variables. It is a small variation on the previous glue.
;;         
;; * num-potential-initial-states = num-init-alts
;;
;; * found-initial?
;; * found-bug?
;; 
;; * (define (init-engine)
;;      (set! found-initial? #f)
;;      (set! found-bug? #f))
;;
;; * (define (next-init idx)
;;      (next-init-alt))
;;
;; * (define (exec-init idx)
;;      (exec-init-alt idx)
;;      (eval-det-def-init)
;;      (let ((result (exec-delayed)))
;;        (when result
;;          (set! found-initial? #t))
;;        (unless (check-curr-state)
;;          (set! found-bug? #t))
;;        result))
;;
;; * num-potential-successors = num-trans-alts * num-input-alts
;;
;; * found-successor?
;; * previous-input-idx
;; * deadlock?
;;
;; * (define (set-curr-state bit-stream)
;;     (bit-stream->curr-state bit-stream)
;;     (eval-det-def)
;;     (set! found-successor? #f)
;;     (set! previous-input-idx 0)
;;     (set! deadlock? #f))
;;
;; * (define (next-trans idx)
;;     (let ((input-idx (/fx idx num-trans-alts)))
;;       (unless (= input-idx previous-input-idx)
;;         (cond
;;          (found-successor?
;;            (set! previous-input-idx input-idx)
;;            (set! found-successor? #f))
;;          (else
;;           (set! deadlock? #t))))
;;       (unless deadlock?
;;         (set-input-vars input-idx)
;;         (let ((new-idx (next-trans-alt (remainder idx num-trans-alts))))
;;            (and new-idx
;;                 (+fx (*fx input-idx num-trans-alts) new-idx)))))))
;;
;; * (define (exec-trans idx)
;;     (exec-trans-alt (remainder idx num-trans-alts))
;;     (and (exec-delayed)
;;          (set! found-successor? #t)
;;          (unless (check-next-state)
;;             (set! found-bug? #t))
;;          #t))
;; 
;; CASE 4) LTL CHECKING WITH DEADLOCK CHECKING. 
;;
;; * num-potential-initial-states = num-init-alts * num-monitor-init-alts
;;
;; * found-initial?
;; * found-final?
;; 
;; * (define (init-engine)
;;      (set! found-initial? #f)
;;      (set! found-final? #f))
;;
;; * (define (next-init idx)
;;     (let ((idx1 (next-init-alt (/fx idx num-monitor-init-alts)))
;;           (idx2 (next-monitor-init-alt (remainder idx num-monitor-init-alts))))
;;       (and idx1 idx2
;;            (+fx (*fx idx1 num-monitor-init-alts) idx2))))
;;
;; * (define (exec-init idx)
;;      (exec-monitor-init-alt (/fx idx num-init-alts))
;;      (exec-init-alt (remainder idx num-init-alts))
;;      (eval-det-def-init)
;;      (let ((result (exec-delayed)))
;;        (when result
;;          (set! found-initial? #t))
;;        result))
;;
;; * num-potential-successors = num-trans-alts * num-monitor-trans-alts * num-input-alts
;;
;; * found-successor?
;; * previous-input-idx
;; * deadlock?
;;
;; * (define (set-curr-state bit-stream)
;;     (bit-stream->curr-state bit-stream)
;;     (eval-det-def))
;;
;; * (define (next-succ idx);
;;     (let ((input-idx (/fx idx (* num-trans-alts num-monitor-trans-alts))))
;;       (unless (= input-idx previous-input-idx)
;;         (cond
;;          (found-successor?
;;            (set! previous-input-idx input-idx)
;;            (set! found-successor? #f))
;;          (else
;;           (set! deadlock? #t))))
;;       (unless deadlock?
;;          (set-input-vars input-idx)
;;          (let* ((tmp-idx (/fx 
;;     (set-input-vars (/fx idx (* num-trans-alts num-monitor-trans-alts)))
;;     (let* ((r-idx1 (remainder idx (* num-trans-alts num-monitor-trans-alts)))
;;            (idx1 (next-trans-alt (/fx r-idx1 num-monitor-trans-alts))))
;;        (and idx1 
;;             (let ((r-idx2 (remainder r-idx1 num-monitor-trans-alts)))
;;                   (idx2 (next-monitor-trans-alt r-idx2)))
;;          (+fx (*fx input-idx num-trans-alts num-monitor-trans-alts) (*fx idx1 num-monitor-trans-alts) idx2)))
;;     
;; * (define (exec-trans idx)
;;     (let ((r-idx1 (remainder idx (* num-trans-alts num-monitor-trans-alts))))
;;        (exec-trans-alt r-idx1)
;;        (and (exec-delayed)
;;             (set! found-successor? #t)
;;             (exec-monitor-trans-alt (remainder r-idx1 num-monitor-trans-alts))
;;             (when (check-monitor-final-state)
;;                (set! found-final? #t))
;;             #t)))
;;
;; 

(define *esm-var-vector* #unspecified)

(define (sort-state-vars-for-symmetry-reduction state-vars)
  ;; simple heuristic used to improve symmetry reduction
  (let ((lvl0-queue (make-queue))
        (lvl1-queue (make-queue))
        (lvl2-queue (make-queue)))
    (for-each (lambda (var-decl)
                (let ((lvl (sal-type/symmetry-friendliness (slot-value var-decl :type))))
                  ;; (print (sal-decl/name var-decl) " : " lvl)
                  (case lvl
                    ((0) (queue/insert! lvl0-queue var-decl))
                    ((1) (queue/insert! lvl1-queue var-decl))
                    ((2) (queue/insert! lvl2-queue var-decl))
                    (else (internal-error)))))
              state-vars)
    (queue/append! lvl0-queue (queue->list lvl1-queue))
    (queue/append! lvl0-queue (queue->list lvl2-queue))
    (queue->list lvl0-queue)))

(define-class <sal-esm-engine> () (:esm-module   ;; a reference to the module used to build this execution engine object.
                                   ;; the translation context used to map esm/ast objects in execution code.
                                   :sal-scm-context  
                                   :num-state-vars
                                   :state-vars   ;; list of latched state var decls  
                                   :choice-vars  ;; list of choice var decls
                                   :input-vars   ;; list of input var decls
                                   :det-defined-vars ;; list of deterministic defined var decls
                                   :non-det-defined-vars ;; list of non deterministic define var decls
                                   ;; list of vars that are transient, and not stored in the state
                                   ;; a variable is transient when only its next value is used in
                                   ;; the transition relation
                                   :transient-vars 
                                   ;; The following vector contains 7 sections. 
                                   ;; They are organized in the following way:
                                   ;; 1) input-vars, 
                                   ;; 2) choice-vars
                                   ;; 3) non-det-defined-vars
                                   ;; 4) det-defined-vars
                                   ;; 5) transient-vars
                                   ;; 6) curr-state-vars
                                   ;; 7) next-state-vars
                                   ;; The following slots can be used to access each one of these sections.
                                   :var-vector   
                                   :choice-var-first-idx
                                   :non-det-defined-var-first-idx
                                   :det-defined-var-first-idx
                                   :transient-var-first-idx
                                   :curr-state-var-first-idx
                                   :next-state-var-first-idx
                                   ;; a table which contains the maximum access level of state variables
                                   ;; in the transition section. An access level of a variable is the
                                   ;; maximum nested update performed on a state variable
                                   ;; Example: the assignment x'.1.flag[2] = 10 has access level 3
                                   ;;          the assignment x' = 10 has access level 0
                                   ;;          the assignment y'.1 = TRUE has access level 1
                                   :transition-access-level-table 
                                   :initialization-access-level-table

                                   ;; Action: build initial states
                                   :initialization-action
                                   ;; Action: produce successor states
                                   :transition-action
                                   
                                   ;; reconstruct the value of deterministic 
                                   ;; defined variables... useful for generating counterexamples
                                   :det-definition-action 
                                   
                                   ;; data structure describing how a state is represented in memory
                                   :memory-layout
                                   ;; number of bits used to encode a state
                                   :num-bits           
                                   ;; number of additional scheme objects (not easily encoded as bits) used
                                   ;; to encode a state
                                   :num-objects        
                                   
                                   ;; the following layouts are used to store the choices 
                                   ;; used in a transition step. this information is not
                                   ;; stored in the cache, but in a todo queue/stack
                                   :input-memory-layout  ;; auxiliary memory layout
                                   :choice-memory-layout ;; auxiliary memory layout
                                   :non-det-definition-memory-layout ;; auxiliary layout

                                   ;; number of bits needed to store a particular input,
                                   ;; choice, and non-det definition combination.
                                   ;; This information is mainly used to
                                   ;; produce nice counterexamples.
                                   :aux-num-bits        

                                   ;; layout context: contains definitions used in the memory layouts
                                   :layout-defition-vector

                                   ;; the constraint vector is used to send state information to 
                                   ;; a bit stream (channel). these constraints are used to implement
                                   ;; symmetry reduction
                                   :constraint-vector
                                   
                                   ;; Cached procedure to return the value of a choice variable
                                   ;; from its name
                                   :cached-choice-value-proc
                                   ))



(define (set-section-id! ctx section-id)
  (set-slot-value! ctx :section-id section-id)
  ctx)

(define (check-non-det-definition-not-used-in-initialization esm-module non-det-def-table)
  (let ((bad-use (sal-ast/find (lambda (ast)
                                 (and (instance-of? ast <sal-name-expr>)
                                      (instance-of? (slot-value ast :decl) <sal-state-var-decl>)
                                      (eq-hash-table/get non-det-def-table (slot-value ast :decl))))
                               (slot-value esm-module :initialization))))
    (when bad-use
      (sign-unsupported-feature bad-use "This tool does not allow the use of non-deterministic defined variables in the initialization section."))))

(define (make-sal-esm-engine esm-module sal-scm-ctx property-used-vars)
  (status-message :building-esm-engine)
  (verbose-message 1 "building execution engine...")
  (display-runtime 2 "  building time: ~a secs"
    (lambda ()
      (let* ((detect-deadlocks? *esm-detect-deadlocks?*)
             (symmetry-reduction? *esmc-symmetry-reduction?*)
             (state-vars (slot-value esm-module :state-vars))
             (defined-var-table (sal-module/defined-variables esm-module))
             (defined-vars (eq-hash-table/fold-keys (flip cons) '() defined-var-table))
             (non-det-def-table (make-eq-hash-table))
             (det-definition-code (sal-esm/remove-non-det-parts (slot-value esm-module :definition)
                                                                non-det-def-table))
             (non-det-defined-vars (eq-hash-table/fold-keys (flip cons) '() non-det-def-table))
             (det-defined-vars (difference defined-vars non-det-defined-vars))
             (transient-vars (sal-module/transient-vars esm-module))
             ;; if the variable is used in the property, then remove it from the transient var list.
             (transient-vars (filter (lambda (var-decl)
                                       (not (sal-decl-list/fast-lookup property-used-vars (sal-decl/name var-decl))))
                                     transient-vars))
             (latched-vars (filter (lambda (var-decl)
                                     (and (not (instance-of? var-decl <sal-input-state-var-decl>))
                                          (not (eq-hash-table/get defined-var-table var-decl))
                                          (not (sal-decl-list/fast-lookup transient-vars (sal-decl/name var-decl)))))
                                   state-vars))
             (latched-vars (if symmetry-reduction?
                             (sort-state-vars-for-symmetry-reduction latched-vars)
                             latched-vars))
             (choice-vars (filter (lambda (var-decl)
                                    (instance-of? var-decl <sal-choice-input-state-var-decl>))
                                  state-vars))
             (input-vars (filter (lambda (var-decl)
                                   (and (instance-of? var-decl <sal-input-state-var-decl>)
                                        (not (instance-of? var-decl <sal-choice-input-state-var-decl>))))
                                 state-vars))
             (var-vector-size (+ (length state-vars) (length latched-vars)))
             (var-vector (make-esm-state-vector var-vector-size))
             (transition-access-level-table (make-sal-esm-access-level-table))
             (initialization-access-level-table (make-sal-esm-access-level-table))
             (choice-var-first-idx (length input-vars))
             (non-det-defined-var-first-idx (+ choice-var-first-idx (length choice-vars)))
             (det-defined-var-first-idx (+ non-det-defined-var-first-idx (length non-det-defined-vars)))
             (transient-var-first-idx (+ det-defined-var-first-idx (length det-defined-vars)))
             (curr-state-var-first-idx (+ transient-var-first-idx (length transient-vars)))
             (next-state-var-first-idx (+ curr-state-var-first-idx (length latched-vars)))
             (empty-env (make-empty-env)))
        (check-non-det-definition-not-used-in-initialization esm-module non-det-def-table)
        (unless (null? transient-vars)
          (verbose-message 3 "  the variables ~a are transient, so their values will not be stored."
                           (map sal-decl/name transient-vars)))
        ;; (print "state-vars: " (map sal-decl/name state-vars))
        ;; (print "latched-vars: " (map sal-decl/name latched-vars))
        ;; (print "choice-vars: " (map sal-decl/name choice-vars))
        ;; (sal/pp det-definition-code)
        ;; (print "")
        ;; (print "var-vector-size: " (vector-length var-vector))
        ;; (print "choice-vars: " (map sal-decl/name choice-vars))
        ;; (print "state-vars: " (map sal-decl/name state-vars))
        (multiple-value-bind
            (def-input-independent def-input-dependent)
            (sal-esm-module/break-definition-section esm-module)
          ;; (print "def input independent:")
          ;; (sal/pp def-input-independent)
          ;; (print "------------")
          ;; (print "def input dependent:")
          ;; (sal/pp def-input-dependent)
          ;; (print "------------")
          (sal-esm/collect-access-levels! (slot-value esm-module :transition) transition-access-level-table)
          (sal-esm/collect-access-levels! (slot-value esm-module :initialization) initialization-access-level-table)
          
          (sal-esm-engine-scm-context/core-setup! sal-scm-ctx input-vars choice-vars non-det-defined-vars
                                                  det-defined-vars transient-vars latched-vars)
          (let* ((initialization-action 
                  (mk-initialization-action (slot-value esm-module :initialization) def-input-independent
                                            sal-scm-ctx latched-vars curr-state-var-first-idx var-vector
                                            initialization-access-level-table))
                 (mk-transition-proc (if detect-deadlocks?
                                       mk-deadlock-detection-transition-action
                                       mk-transition-action))
                 (transition-action 
                  (mk-transition-proc (slot-value esm-module :transition) def-input-independent
                                      def-input-dependent sal-scm-ctx curr-state-var-first-idx
                                      next-state-var-first-idx var-vector input-vars latched-vars
                                      transition-access-level-table))
                 (det-definition-action
                  (mk-esm-main-action
                   (lambda ()
                     (esm->scm det-definition-code (set-section-id! sal-scm-ctx 'definition) empty-env 0))))
                 (engine (make-instance <sal-esm-engine>
                                        :esm-module esm-module
                                        :sal-scm-context sal-scm-ctx
                                        :num-state-vars (length latched-vars)
                                        :state-vars latched-vars
                                        :choice-vars choice-vars
                                        :input-vars input-vars
                                        :non-det-defined-vars non-det-defined-vars
                                        :det-defined-vars det-defined-vars
                                        :transient-vars transient-vars
                                        
                                        :var-vector var-vector
                                        
                                        :choice-var-first-idx choice-var-first-idx
                                        :non-det-defined-var-first-idx non-det-defined-var-first-idx
                                        :det-defined-var-first-idx det-defined-var-first-idx
                                        :transient-var-first-idx transient-var-first-idx
                                        :curr-state-var-first-idx curr-state-var-first-idx
                                        :next-state-var-first-idx next-state-var-first-idx
                                        
                                        :transition-access-level-table transition-access-level-table
                                        :initialization-access-level-table initialization-access-level-table
                                        
                                        :initialization-action initialization-action
                                        :transition-action transition-action
                                        :det-definition-action det-definition-action
                                        )))
            (setup-memory-layouts! engine symmetry-reduction?)
            engine))))
    :esm-building-engine-time))
            

(define (setup-memory-layouts! engine symmetry-reduction?)
  (let ((sal-scm-ctx (slot-value engine :sal-scm-context))
        (state-vars (slot-value engine :state-vars))
        (input-vars (slot-value engine :input-vars))
        (choice-vars (slot-value engine :choice-vars))
        (non-det-defined-vars (slot-value engine :non-det-defined-vars)))
    (cond
     (symmetry-reduction? 
      (let ((pre-ctx (make-pre-symmetry-layout-context)))
        (set-slot-value! engine :memory-layout (mk-symmetric-memory-layout state-vars sal-scm-ctx pre-ctx))
        (set-slot-value! engine :input-memory-layout (mk-symmetric-memory-layout input-vars sal-scm-ctx pre-ctx))
        (set-slot-value! engine :choice-memory-layout (mk-symmetric-memory-layout choice-vars sal-scm-ctx pre-ctx))
        (set-slot-value! engine :non-det-definition-memory-layout (mk-symmetric-memory-layout non-det-defined-vars sal-scm-ctx pre-ctx))
        (let ((ctx (pre-symmetry-layout-context->symmetry-layout-context pre-ctx)))
          (set-slot-value! engine :layout-defition-vector (symmetry-layout-context/layout-definition-vector ctx))
          (set-slot-value! engine :constraint-vector (symmetry-layout-context/make-symmetry-constraint-vector ctx)))))
     (else
      (set-slot-value! engine :memory-layout (mk-memory-layout state-vars sal-scm-ctx))
      (set-slot-value! engine :input-memory-layout (mk-memory-layout input-vars sal-scm-ctx))
      (set-slot-value! engine :choice-memory-layout (mk-memory-layout choice-vars sal-scm-ctx))
      (set-slot-value! engine :non-det-definition-memory-layout (mk-memory-layout non-det-defined-vars sal-scm-ctx))))
    (multiple-value-bind
        (num-bits num-objs)
        (memory-layout/num-bits-and-num-objs (slot-value engine :memory-layout) (slot-value engine :layout-defition-vector))
      (status-message :esm-engine-info num-bits num-objs (sec/obj-num-bits))
      (verbose-message 2 "  num. bits used to encode a state: ~a" (+ num-bits (* (sec/obj-num-bits) num-objs)))
      (when (> num-objs 0)
        (verbose-message 2 "  num. objects that are mapped to numbers: ~a" num-objs))
      (set-slot-value! engine :num-bits num-bits)
      (set-slot-value! engine :num-objects num-objs)
      (set-slot-value! engine :aux-num-bits (auxiliary-num-bits (slot-value engine :input-memory-layout)
                                                                (slot-value engine :choice-memory-layout)
                                                                (slot-value engine :non-det-definition-memory-layout)
                                                                (slot-value engine :layout-defition-vector))))))

(define (mk-memory-layout vars ctx)
  (list->vector (map (lambda (var-decl)
                       (sal-type/esm-memory-layout (slot-value var-decl :type) ctx))
                     vars)))

(define (mk-symmetric-memory-layout vars ctx pre-ctx)
  (list->vector (map (lambda (var-decl)
                       (sal-type/esm-symmetric-memory-layout (slot-value var-decl :type) ctx pre-ctx))
                     vars)))

(define (auxiliary-num-bits input-memory-layout choice-memory-layout non-det-definition-memory-layout layout-definition-vector)
  (multiple-value-bind
      (input-num-bits input-num-objs)
      (memory-layout/num-bits-and-num-objs input-memory-layout layout-definition-vector)
    [assert (input-num-objs) (= input-num-objs 0)]
    (multiple-value-bind
        (choice-num-bits choice-num-objs)
        (memory-layout/num-bits-and-num-objs choice-memory-layout layout-definition-vector)
      [assert (choice-num-objs) (= choice-num-objs 0)]
      (multiple-value-bind
          (non-det-def-num-bits non-det-def-num-objs)
          (memory-layout/num-bits-and-num-objs non-det-definition-memory-layout layout-definition-vector)
        [assert (non-det-def-num-objs) (= non-det-def-num-objs 0)]
        (+ input-num-bits choice-num-bits non-det-def-num-bits)))))
    
(define (mk-initialization-action initialization def-input-independent ctx latched-vars curr-state-var-first-idx var-vector
                                  initialization-access-level-table)
  (let ((empty-env (make-empty-env)))
    (mk-esm-main-action
     (lambda ()
       (mk-esm-seq-action
        (lambda ()
          (esm->scm initialization
                    (set-section-id! ctx 'initialization)
                    empty-env
                    0))
        (lambda ()
          ;; Remark: only input independent definitions are included
          ;; in the initialization
          (esm->scm def-input-independent 
                    (set-section-id! ctx 'definition)
                    empty-env 
                    0))
        (lambda ()
          (mk-esm-execute-delayed-actions-action))
        (lambda ()
          ((fill-unassigned-vars-proc ctx)
           ctx
           latched-vars
           curr-state-var-first-idx
           var-vector
           initialization-access-level-table)))))))

(define (fill-unassigned-vars-proc ctx)
  (cond
   ((and (slot-value ctx :randomize?) (slot-value ctx :restricted-randomization?))
    mk-esm-committed-random-fill-unassinged-state-vars-action)
   ((slot-value ctx :randomize?)
    mk-esm-random-fill-unassinged-state-vars-action)
   (else
    mk-esm-non-det-fill-unassinged-state-vars-action)))

(define (mk-transition-action transition def-input-independent def-input-dependent ctx curr-state-var-first-idx
                              next-state-var-first-idx var-vector input-vars latched-vars transition-access-level-table)
  (let ((empty-env (make-empty-env)))
    (mk-esm-main-action
     (lambda ()
       (mk-esm-seq-action                            
        ;; remark: little optimization, definitions that are independent of
        ;; input vars are executed before the non-det choice of input vars
        (lambda ()
          (esm->scm def-input-independent 
                    (set-section-id! ctx 'definition) 
                    empty-env 
                    0))
        (lambda ()
          ((non-det-input-vars-proc ctx) 
           ctx
           input-vars
           var-vector))
        (lambda ()
          (esm->scm def-input-dependent 
                    (set-section-id! ctx 'definition) 
                    empty-env 
                    0))
        (lambda ()
          (mk-esm-execute-delayed-actions-action))
        (lambda ()
          (esm->scm transition
                    (set-section-id! ctx 'transition)
                    empty-env
                    0))
        (lambda ()
          (mk-esm-execute-delayed-actions-action))
        (lambda ()
          (mk-esm-fill-unassinged-state-vars-action latched-vars
                                                    curr-state-var-first-idx
                                                    next-state-var-first-idx
                                                    var-vector
                                                    transition-access-level-table)))))))

(define *esm-deadlock-detected* #f)

(define-inline (sal-esm-engine/deadlock?)
  *esm-deadlock-detected*)

(define (mk-deadlock-detection-transition-action transition def-input-independent def-input-dependent ctx curr-state-var-first-idx
                                                 next-state-var-first-idx var-vector input-vars latched-vars transition-access-level-table)
  (when (has-monitor? transition)
    (sign-error "Deadlock detection cannot be used during the verification of properties which are not invariants."))
  (let ((empty-env (make-empty-env))
        (use-next? (sal-esm/uses-next-operator? transition)))
    (mk-esm-main-action
     (lambda ()
       (mk-esm-seq-action                            
        (lambda ()
          ((non-det-input-vars-proc ctx) 
           ctx
           input-vars
           var-vector))
        (lambda ()
          (mk-esm-choice-action
           (lambda ()
             (mk-esm-seq-action
              (lambda ()
                (mk-esm-primitive-action (lambda ()
                                           ;; Assume the state does not have a successor for the given inputs.
                                           ;; I reset the flag, it is possible to execute at least one transition.
                                           (set! *esm-deadlock-detected* #t))
                                         transition))
              (lambda ()
                (esm->scm def-input-independent 
                          (set-section-id! ctx 'definition) 
                          empty-env 
                          0))
              (lambda ()
                (esm->scm def-input-dependent 
                          (set-section-id! ctx 'definition) 
                          empty-env 
                          0))
              (lambda ()
                (mk-esm-execute-delayed-actions-action))
              (lambda ()
                (esm->scm transition
                          (set-section-id! ctx 'transition)
                          empty-env
                          0))
              (lambda ()
                (mk-esm-execute-delayed-actions-action))
              (lambda ()
                (mk-esm-fill-unassinged-state-vars-action latched-vars
                                                          curr-state-var-first-idx
                                                          next-state-var-first-idx
                                                          var-vector
                                                          transition-access-level-table))
              (lambda ()
                (mk-esm-execute-delayed-actions-action))
              (lambda ()
                (mk-esm-primitive-action (lambda ()
                                           ;; the current state has a successor for that input variables.
                                           (set! *esm-deadlock-detected* #f))
                                         transition))))
           (lambda ()
             (mk-esm-primitive-action (lambda ()
                                        ;; this is not a real alternative if a deadlock was not detected.
                                        (unless *esm-deadlock-detected*
                                        (esm/fail)))
                                      transition)))))))))
  

(define-generic (has-monitor? transition))
(define-method (has-monitor? (transition <sal-esm-monitor-seq>))
  #t)
(define-method (has-monitor? (transition <primitive>))
  #f)

(define (non-det-input-vars-proc ctx)
  (if (slot-value ctx :randomize?)
    mk-esm-input-vars-random-choice-action
    mk-esm-input-vars-non-det-choice-action))
  
(define (sal-esm-engine-scm-context/core-setup! ctx input-vars choice-vars non-det-defined-vars
                                                det-defined-vars transient-vars state-vars)
  (let* ((idx 0)
         (curr-var-idx-table (make-eq-hash-table))
         (next-var-idx-table (make-eq-hash-table))
         (fill-tables! (lambda (table1 table2 var-list)
                         (for-each (lambda (var)
                                     ;; (print (sal-decl/name var) " -> " idx)
                                     (eq-hash-table/put! table1 var idx)
                                     (when table2
                                       (eq-hash-table/put! table2 var idx))
                                     (set! idx (+ idx 1)))
                                   var-list)))
         (fill-table! (lambda (table var-list)
                        (fill-tables! table #f var-list))))
    (fill-table! curr-var-idx-table input-vars)
    (fill-table! next-var-idx-table choice-vars)
    (fill-table! curr-var-idx-table non-det-defined-vars)
    (fill-table! curr-var-idx-table det-defined-vars)
    (fill-tables! curr-var-idx-table next-var-idx-table transient-vars)
    (fill-table! curr-var-idx-table state-vars)
    (fill-table! next-var-idx-table state-vars)
    ;; (print "idx : " idx) 
    (set-slot-value! ctx :curr-var-idx-table curr-var-idx-table)
    (set-slot-value! ctx :next-var-idx-table next-var-idx-table)
    (new-core-setup! ctx input-vars choice-vars non-det-defined-vars
                     det-defined-vars transient-vars state-vars)
    ))

(define (new-core-setup! ctx input-vars choice-vars non-det-defined-vars det-defined-vars transient-vars state-vars)
  (let* ((curr-var-name-table (make-eq-hash-table))
         (next-var-name-table (make-eq-hash-table)) 
         (gen-global-var (lambda (var)
                           (let ((new-name (gen-unique-name (sal-decl/name var))))
                             (sal-scm-context/add-decl! ctx `(define ,new-name #unspecified))
                             new-name)))
         (fill-tables! (lambda (table1 table2 var-list)
                         (for-each (lambda (var)
                                     (eq-hash-table/put! table1 var (gen-global-var var))
                                     (when table2
                                       (eq-hash-table/put! table2 var (gen-global-var var))))
                                   var-list)))
         (fill-table! (lambda (table var-list)
                        (fill-tables! table #f var-list))))
    (fill-table! curr-var-name-table input-vars)
    (fill-table! next-var-name-table choice-vars)
    (fill-table! curr-var-name-table non-det-defined-vars)
    (fill-table! curr-var-name-table det-defined-vars)
    (fill-tables! curr-var-name-table next-var-name-table transient-vars)
    (fill-table! curr-var-name-table state-vars)
    (fill-table! next-var-name-table state-vars)
    (set-slot-value! ctx :curr-var-name-table curr-var-name-table)
    (set-slot-value! ctx :next-var-name-table next-var-name-table)))

(define-method (sal->scm (ast <sal-name-expr>) (ctx <sal-esm-engine-scm-context>) (env <primitive>))
  (let ((decl (slot-value ast :decl)))
    (cond
     ((lookup-env decl env) =>
      identity)
     ((eq-hash-table/get (slot-value ctx :curr-var-idx-table) decl) =>
      (lambda (entry)
        `(vector-ref *esm-var-vector* ,(cdr entry))))
     (else
      (sign-sal-to-scm-error ast "Undefined name `~a'" (sal-name-ref/name ast))))))

(define-method (sal->scm (ast <sal-next-operator>) (ctx <sal-esm-engine-scm-context>) (env <primitive>))
  (let ((decl (slot-value (slot-value ast :name-expr) :decl)))
    (cond
     ((eq-hash-table/get (slot-value ctx :next-var-idx-table) decl) =>
      (lambda (entry)
        `(vector-ref *esm-var-vector* ,(cdr entry))))
     (else
      (let ((kind (if (instance-of? decl <sal-input-state-var-decl>)
                    "input "
                    "")))
        (sign-sal-to-scm-error ast 
                               "The next value of the ~avariable `~a' is not supported by this tool." 
                               kind
                               (sal-name-ref/name (slot-value ast :name-expr))))))))

(define-generic (esm->scm esm ctx env var-bound-idx))

(define-method (esm->scm (esm <primitive>) (ctx <sal-esm-engine-scm-context>) (env <primitive>) (var-bound-idx <primitive>))
  (mk-esm-primitive-action (lambda ()
                             ;; do nothing...
                             #unspecified)
                           #f))

;; Combine guards that cannot be delayed in a single guard.
(define (combine-guards statements place-provider)
  (let ((other-statements (make-queue))
        (guard-exprs (make-queue)))
    (for-each (lambda (stmt)
                (if (and (instance-of? stmt <sal-esm-guard>)
                         (not (sal-ast/uses-next-operator? stmt)))
                  (queue/insert! guard-exprs (slot-value stmt :expr))
                  (queue/insert! other-statements stmt)))
              statements)
    (if (queue/empty? guard-exprs)
      statements
      (cons (make-ast-instance <sal-esm-guard> place-provider
                               :expr (make-sal-and* (queue->list guard-exprs) place-provider))
            (queue->list other-statements)))))

(define-method (esm->scm (esm <sal-esm-seq>) (ctx <sal-esm-engine-scm-context>) (env <primitive>) 
                         (var-bound-idx <primitive>))
  (let ((new-statements (combine-guards (slot-value esm :statements) esm)))
    (mk-esm-seq-action* (map (lambda (stmt)
                               (lambda ()
                                 (esm->scm stmt ctx env var-bound-idx)))
                             new-statements))))

(define (mk-choice-core esm ctx env var-bound-idx mk-choice-proc)
  (mk-choice-proc (map (lambda (stmt)
                         (lambda () 
                           (esm->scm stmt ctx env var-bound-idx)))
                       (slot-value esm :statements))))
  

(define-method (esm->scm (esm <sal-esm-choice>) (ctx <sal-esm-engine-scm-context>) (env <primitive>) (var-bound-idx <primitive>))
  (if (slot-value ctx :randomize?)
    (mk-choice-core esm ctx env var-bound-idx mk-esm-random-choice-action*)
    (mk-choice-core esm ctx env var-bound-idx mk-esm-choice-action*)))

(define (mk-binds-action-core esm ctx env var-bound-idx mk-multi-action-proc)
  ;; (breakpoint "mk-binds-action-core" (esm ctx env bound-names mk-multi-action-proc) #t)
  (let* ((local-decls (slot-value esm :local-decls))
         (new-var-bound-idx var-bound-idx)
         (new-binds (map (lambda (decl)
                           (let ((curr-idx new-var-bound-idx))
                             (set! new-var-bound-idx (+ new-var-bound-idx 1))
                             `(esm/bounded-value ,curr-idx)))
                         local-decls))
         (value-lists (map (lambda (decl)
                             (let ((it (sal-type->scm-iterator (slot-value decl :type) ctx env)))
                               ;; (print it)
                               (iterator->list (eval it))))
                           local-decls))
         (new-env (update-env* env local-decls new-binds)))
    ;; (print value-lists)
    (let loop ((value-lists value-lists))
      (if (null? value-lists)
        (esm->scm (slot-value esm :statement) ctx new-env new-var-bound-idx)
        (mk-multi-action-proc (car value-lists)
                              (lambda ()
                                (loop (cdr value-lists))))))))

(define-method (esm->scm (esm <sal-esm-multi-seq>) (ctx <sal-esm-engine-scm-context>) (env <primitive>) (var-bound-idx <primitive>))
  (mk-binds-action-core esm ctx env var-bound-idx mk-esm-multi-seq-action))

(define-method (esm->scm (esm <sal-esm-multi-choice>) (ctx <sal-esm-engine-scm-context>) (env <primitive>) (var-bound-idx <primitive>))
  (if (slot-value ctx :randomize?)
    (mk-binds-action-core esm ctx env var-bound-idx mk-esm-multi-random-choice-action)
    (mk-binds-action-core esm ctx env var-bound-idx mk-esm-multi-choice-action)))

(define (simple-code? code)
  (or (number? code) (boolean? code)))

(define (esm-sal-expr->scm expr ctx env)
  (let ((body (sal->scm expr ctx env)))
    (if (simple-code? body)
      body
      (sal-esm-engine-scm-context/add-definition! ctx `(lambda () ,body) 'act))))

(define-method (esm->scm (esm <sal-esm-guard>) (ctx <sal-esm-engine-scm-context>) (env <primitive>) (var-bound-idx <primitive>))
  (let ((code (esm-sal-expr->scm (slot-value esm :expr) ctx env)))
    (if (boolean? code)
      (mk-esm-guard-action (lambda () code) esm)
      ;; if code is not a boolean, then it is the name of procedure
      ;; that returns a boolean. The expression (eval code) returns
      ;; the procedure. It performs the dynamic binding between 
      ;; the generated code and the action. Remark: the generated
      ;; code may reside in a dynamic link library.
      (let ((pred #f))
        (mk-esm-guard-action (lambda () 
                               (unless pred
                                 ;; binds pred to the actual procedure
                                 (set! pred (eval code)))
                               (pred))
                             esm)))))

(define-generic (sal-lhs->access-list lhs ctx env))

(define-method (sal-lhs->access-list (lhs <sal-name-expr>) (ctx <sal-esm-engine-scm-context>) (env <primitive>))
  '())
(define-method (sal-lhs->access-list (lhs <sal-next-operator>) (ctx <sal-esm-engine-scm-context>) (env <primitive>))
  '())
(define (lhs->access-list-core lhs ctx env idx)
  (let* ((target (sal-selection/target lhs))
         (type (sal-expr/type target))
         (size (sal-type/number-of-elements-as-integer type)))
    (append (sal-lhs->access-list target ctx env)
            (list (cons size idx)))))
(define-method (sal-lhs->access-list (lhs <sal-tuple-selection>) (ctx <sal-esm-engine-scm-context>) (env <primitive>))
  (lhs->access-list-core lhs ctx env (sal-tuple-index->scm-index (slot-value lhs :idx))))
(define-method (sal-lhs->access-list (lhs <sal-record-selection>) (ctx <sal-esm-engine-scm-context>) (env <primitive>))
  (lhs->access-list-core lhs ctx env (sal-record-index->scm-index (slot-value lhs :target) (slot-value lhs :idx))))
(define-method (sal-lhs->access-list (lhs <sal-array-selection>) (ctx <sal-esm-engine-scm-context>) (env <primitive>))
  (let* ((fun (slot-value lhs :fun))
         (type (sal-expr/type fun))
         (domain (sal-function-type/domain type)))
    (let ((idx (sal-type/val->idx domain ctx env (sal->scm (slot-value lhs :arg) ctx env))))
      (if (number? idx)
        (lhs->access-list-core lhs ctx env idx)
        (let ((idx-id (sal-esm-engine-scm-context/add-definition! ctx `(lambda () ,idx) 'idx)))
          (lhs->access-list-core lhs ctx env idx-id))))))
  
(define-inline (eval-rhs rhs-proc)
  (try
   (if (procedure? rhs-proc)
     (rhs-proc)
     rhs-proc)
   (lambda (e p m o)
     (cond
      ((eq? p 'esm-delay-action)
       (e 'delayed))
      (else
       (error p m o))))))

(define-generic (make-assignment-body lhs ctx env var-idx access-list rhs-code))
(define-method (make-assignment-body (lhs <sal-expr>) (ctx <sal-esm-engine-scm-context>) (env <primitive>)
                                     (var-idx <primitive>) (access-list <primitive>) (rhs-code <primitive>))
  (if (slot-value ctx :runtime-type-check?)
    ;; instrumented code
    (let* ((lhs-type (sal-expr/type lhs))
           (check-lhs-pred (sal-type/gen-check-membership-pred lhs-type ctx env))
           (check-lhs-code (sal-esm-engine-scm-context/add-definition! ctx check-lhs-pred 'rhs-type-check))
           (rhs-proc #f)
           (check-lhs-proc #f)
           (ctx-name (sal-context/name (sal-ast/context lhs)))
           (line (sal-place/initial-line (sal-ast/place lhs)))
           (column (sal-place/initial-column (sal-ast/place lhs))))
      (lambda ()
        (unless rhs-proc
          ;; binds rhs-proc to the actual procedure
          (set! rhs-proc (eval rhs-code)))
        (unless check-lhs-proc
          (set! check-lhs-proc (eval check-lhs-code)))
        (let ((rhs-value (eval-rhs rhs-proc)))
          (when (and (not (eq? rhs-value 'delayed)) (not (check-lhs-proc rhs-value)))
            (sign-sal-scm-runtime-type-error-core ctx-name line column "Invalid right-hand-side." rhs-value lhs-type ctx))
          (sal-esm/safe-update-composite-state-var! *esm-var-vector* var-idx access-list rhs-value 
                                                    ctx-name line column)
          (when (eq? rhs-value 'delayed)
            (esm/delay)))))
    ;; non instrumented version
    (let ((rhs-proc #f))
      (lambda ()
        (unless rhs-proc
          ;; binds rhs-proc to the actual procedure
          (set! rhs-proc (eval rhs-code)))
        (let ((rhs-value (eval-rhs rhs-proc)))
          (sal-esm/update-composite-state-var! *esm-var-vector* var-idx access-list rhs-value)
          (when (eq? rhs-value 'delayed)
            (esm/delay)))))))

(define (esm-assignment->primitive-action-body esm ctx env var-bound-idx)
  (let* ((rhs-code (esm-sal-expr->scm (slot-value esm :rhs) ctx env))
         (lhs (slot-value esm :lhs))
         (name-expr (sal-lhs/name-expr lhs))
         (var-decl (slot-value name-expr :decl))
         (var-idx-table (if (eq? (slot-value ctx :section-id) 'transition)
                          (slot-value ctx :next-var-idx-table)
                          (slot-value ctx :curr-var-idx-table)))
         (var-idx (cond 
                   ((eq-hash-table/get var-idx-table var-decl) => cdr)
                   (else 
                    ;; (breakpoint "esm->scm" (ctx env var-idx-table var-decl esm) #t)
                    (internal-error))))
         (access-list (sal-lhs->access-list lhs ctx env)))
    (make-assignment-body lhs ctx env var-idx access-list rhs-code)))

(define-method (esm->scm (esm <sal-esm-assignment>) (ctx <sal-esm-engine-scm-context>) (env <primitive>) 
                         (var-bound-idx <primitive>))
  (let ((proc (esm-assignment->primitive-action-body esm ctx env var-bound-idx)))
    (mk-esm-primitive-action proc esm)))

(define (sal-esm-engine/reset-var-vector! esm-engine)
  (set! *esm-deadlock-detected* #f)
  (vector-fill! (slot-value esm-engine :var-vector) 'not-assigned)
  (set! *esm-var-vector* (slot-value esm-engine :var-vector)))

(define (display-state-core esm-engine first-idx)
  (let ((var-vector (slot-value esm-engine :var-vector))
        (num-state-vars (slot-value esm-engine :num-state-vars)))
    (display "[")
    (let loop ((i 0))
      (when (< i num-state-vars)
        (when (> i 0) (display " "))
        (display (vector-ref var-vector (+ first-idx i)))
        (loop (+ i 1))))
    (display "]")))

(define (display-curr-state esm-engine)
  (display-state-core esm-engine (slot-value esm-engine :curr-state-var-first-idx)))

(define (display-next-state esm-engine)
  (display-state-core esm-engine (slot-value esm-engine :next-state-var-first-idx)))

(define (sal-esm-engine/set-curr-memory-layout! esm-engine)
  (memory-layout->var-vector (slot-value esm-engine :memory-layout)
                             (slot-value esm-engine :var-vector)
                             (slot-value esm-engine :curr-state-var-first-idx)
                             (slot-value esm-engine :layout-defition-vector)))

(define (sal-esm-engine/set-other-memory-layout! esm-engine)
  (memory-layout->var-vector (slot-value esm-engine :input-memory-layout)
                             (slot-value esm-engine :var-vector)
                             0
                             (slot-value esm-engine :layout-defition-vector))
  (memory-layout->var-vector (slot-value esm-engine :choice-memory-layout)
                             (slot-value esm-engine :var-vector)
                             (slot-value esm-engine :choice-var-first-idx)
                             (slot-value esm-engine :layout-defition-vector))
  (memory-layout->var-vector (slot-value esm-engine :non-det-definition-memory-layout)
                             (slot-value esm-engine :var-vector)
                             (slot-value esm-engine :non-det-defined-var-first-idx)
                             (slot-value esm-engine :layout-defition-vector)))

(define (mk-set-curr-state-proc engine)
  (let ((memory-layout (slot-value engine :memory-layout))
        (curr-state-var-first-idx (slot-value engine :curr-state-var-first-idx))
        (next-state-var-first-idx (slot-value engine :next-state-var-first-idx))
        (var-vector-size (vector-length (slot-value engine :var-vector)))
        (layout-def-vect (slot-value engine :layout-defition-vector)))
    (lambda (channel)
      (output-channel->var-vector! channel *esm-var-vector* curr-state-var-first-idx memory-layout layout-def-vect)
      (vector/fill-from-to! *esm-var-vector* 0 curr-state-var-first-idx 'not-assigned)
      (vector/fill-from-to! *esm-var-vector* next-state-var-first-idx var-vector-size 'not-assigned))))

(define (mk-copy-next-state-to-channel-proc engine)
  (let ((memory-layout (slot-value engine :memory-layout))
        (next-state-var-first-idx (slot-value engine :next-state-var-first-idx))
        (layout-def-vect (slot-value engine :layout-defition-vector))
        (constraint-vect (slot-value engine :constraint-vector)))
    (lambda (channel)
      (when constraint-vect
        (symmetry-constraint-vector/reset! constraint-vect))
      (var-vector->input-channel! *esm-var-vector* next-state-var-first-idx memory-layout layout-def-vect constraint-vect channel)
      (when constraint-vect
        (symmetry-constraint-vector/fill! constraint-vect)))))

(define (mk-copy-curr-state-to-channel-proc engine)
  (let ((memory-layout (slot-value engine :memory-layout))
        (curr-state-var-first-idx (slot-value engine :curr-state-var-first-idx))
        (layout-def-vect (slot-value engine :layout-defition-vector))
        (constraint-vect (slot-value engine :constraint-vector)))
    (lambda (channel)
      (when constraint-vect
        (symmetry-constraint-vector/reset! constraint-vect))
      (var-vector->input-channel! *esm-var-vector* curr-state-var-first-idx memory-layout layout-def-vect constraint-vect channel)
      (when constraint-vect
        (symmetry-constraint-vector/fill! constraint-vect)))))

(define (mk-copy-selection-vars-to-channel-proc engine)
  (let ((input-memory-layout (slot-value engine :input-memory-layout))
        (choice-memory-layout (slot-value engine :choice-memory-layout))
        (non-det-def-memory-layout (slot-value engine :non-det-definition-memory-layout))
        (choice-var-first-idx (slot-value engine :choice-var-first-idx))
        (non-det-defined-var-first-idx (slot-value engine :non-det-defined-var-first-idx))
        (layout-def-vect (slot-value engine :layout-defition-vector))
        (constraint-vect (slot-value engine :constraint-vector)))
    (lambda (channel)
      (var-vector->input-channel! *esm-var-vector* 0 input-memory-layout layout-def-vect constraint-vect channel)
      (var-vector->input-channel! *esm-var-vector* choice-var-first-idx choice-memory-layout layout-def-vect constraint-vect channel)
      (var-vector->input-channel! *esm-var-vector* non-det-defined-var-first-idx non-det-def-memory-layout layout-def-vect constraint-vect channel))))

(define (vars->assignment-table! first-idx var-decls ctx assignment-table)
  (let ((curr-var-idx first-idx))
    (for-each (lambda (var-decl)
                (let* ((scm-value (vector-ref *esm-var-vector* curr-var-idx))
                       (type (slot-value var-decl :type))
                       (sal-value (scm-value->sal scm-value type ctx)))
                  (eq-hash-table/put! assignment-table var-decl sal-value)
                  (set! curr-var-idx (+ curr-var-idx 1))))
              var-decls)))

(define (mk-channel-curr-vars-to-assignment-table-proc engine)
  (let ((curr-state-var-first-idx (slot-value engine :curr-state-var-first-idx))
        (state-vars (slot-value engine :state-vars))
        (ctx (slot-value engine :sal-scm-context))
        (memory-layout (slot-value engine :memory-layout))
        (layout-def-vect (slot-value engine :layout-defition-vector)))
    (lambda (channel assignment-table)
      (output-channel->var-vector! channel *esm-var-vector* curr-state-var-first-idx memory-layout layout-def-vect)
      (vars->assignment-table! curr-state-var-first-idx state-vars ctx assignment-table))))

(define (mk-channel-inputs-to-assignment-table-proc engine)
  (let ((input-vars (slot-value engine :input-vars))
        (choice-vars (slot-value engine :choice-vars))
        (det-defined-vars (slot-value engine :det-defined-vars))
        (non-det-defined-vars (slot-value engine :non-det-defined-vars))
        (choice-var-first-idx (slot-value engine :choice-var-first-idx))
        (det-defined-var-first-idx (slot-value engine :det-defined-var-first-idx))
        (curr-state-var-first-idx (slot-value engine :curr-state-var-first-idx))
        (non-det-defined-var-first-idx (slot-value engine :non-det-defined-var-first-idx))
        (det-definition-action (slot-value engine :det-definition-action))
        (ctx (slot-value engine :sal-scm-context))
        (input-memory-layout (slot-value engine :input-memory-layout))
        (choice-memory-layout (slot-value engine :choice-memory-layout))
        (non-det-definition-memory-layout (slot-value engine :non-det-definition-memory-layout))
        (layout-def-vect (slot-value engine :layout-defition-vector)))
    (sal-esm-engine/set-other-memory-layout! engine) ;; it is necessary for output-channel->var-vector!
    (lambda (channel assignment-table)
      (output-channel->var-vector! channel *esm-var-vector* 0 input-memory-layout layout-def-vect)
      (output-channel->var-vector! channel *esm-var-vector* choice-var-first-idx choice-memory-layout layout-def-vect)
      (output-channel->var-vector! channel *esm-var-vector* non-det-defined-var-first-idx non-det-definition-memory-layout layout-def-vect)
      (vector/fill-from-to! *esm-var-vector* det-defined-var-first-idx curr-state-var-first-idx 'not-assigned)      
      (unless (esm/execute-action det-definition-action)
        (sign-error "Invalid specification, definition section produces a deadlock"))
      (vars->assignment-table! non-det-defined-var-first-idx non-det-defined-vars ctx assignment-table)
      (vars->assignment-table! det-defined-var-first-idx det-defined-vars ctx assignment-table)
      (vars->assignment-table! 0 input-vars ctx assignment-table)
      (vars->assignment-table! choice-var-first-idx choice-vars ctx assignment-table))))

(define (sal-esm-engine/display-var-values engine var-decls first-idx)
  (let ((curr-idx first-idx)
        (ctx (slot-value engine :sal-scm-context)))
    (for-each (lambda (var-decl)
                (let* ((type (slot-value var-decl :type))
                       (val (vector-ref *esm-var-vector* curr-idx))
                       (sal-val (scm-value->sal val type ctx)))
                  (sal-var-decl/display-value var-decl sal-val)
                  (set! curr-idx (+ curr-idx 1))))
              var-decls)))

(define (sal-esm-engine/display-curr-state engine)
  (print "State Variables: ")
  (sal-esm-engine/display-var-values engine (slot-value engine :state-vars) (slot-value engine :curr-state-var-first-idx)))

(define (sal-esm-engine/display-next-state engine)
  (print "Next State Variables: ")
  (sal-esm-engine/display-var-values engine (slot-value engine :state-vars) (slot-value engine :next-state-var-first-idx)))
    
(define (sal-esm-engine/display-transition-info engine)
  (unless (slot-value engine :cached-choice-value-proc)
    (let ((ctx (slot-value engine :sal-scm-context))
          (choice-vars (slot-value engine :choice-vars))
          (choice-var-table (make-eq-hash-table))
          (idx (slot-value engine :choice-var-first-idx)))
      (for-each (lambda (choice-var-decl)
                  (eq-hash-table/put! choice-var-table (sal-decl/name choice-var-decl) (cons (slot-value choice-var-decl :type) idx))
                  (set! idx (+ idx 1)))
                choice-vars)
      (set-slot-value! engine :cached-choice-value-proc (lambda (name)
                                                          (cond
                                                           ((eq-hash-table/get choice-var-table name) =>
                                                            (lambda (entry)
                                                              (let* ((info (cdr entry))
                                                                     (type (car info))
                                                                     (idx (cdr info))
                                                                     (choice-val (vector-ref *esm-var-vector* idx))
                                                                     (choice-sal-val (scm-value->sal choice-val type ctx)))
                                                                ;;(breakpoint "display-transition" 
                                                                ;;     (engine entry name choice-var-table choice-sal-val) #t)
                                                                choice-sal-val)))
                                                           (else 
                                                            [assert (name choice-var-table) #f]
                                                            #f))))))
  (let* ((transition-step (make-sal-transition-step 
                           (slot-value (slot-value engine :esm-module) :transition-trace-info)
                           (slot-value engine :cached-choice-value-proc)))
         (transition-doc (sal-transition-step->doc transition-step #t)))
    (print "---------------------------------------")
    (print "Transition Information: ")
    (sal/pretty transition-doc)
    (print "")
    (unless (null? (slot-value engine :input-vars))
      (print "Input variables: ")
      (sal-esm-engine/display-var-values engine (slot-value engine :input-vars) 0))
    (unless (and (null? (slot-value engine :non-det-defined-vars))
                 (null? (slot-value engine :det-defined-vars)))
      (print "Definitions: ")
      (sal-esm-engine/display-var-values engine (slot-value engine :non-det-defined-vars) (slot-value engine :non-det-defined-var-first-idx))
      (sal-esm-engine/display-var-values engine (slot-value engine :det-defined-vars) (slot-value engine :det-defined-var-first-idx)))))
    
(define (sal-esm/display-ce-found-message num-states)
  (when num-states
    (status-message :esm-num-visited-states num-states)
    (verbose-message 2 "  number of visited states: ~a" num-states))
  (cond
   ((sal-esm-engine/deadlock?)
    (status-message :esm-deadlock)
    (verbose-message 2 "  DEADLOCK found, generating path..."))
   (else
    (status-message :esm-invalid)
    (verbose-message 2 "  INVALID, generating counterexample..."))))
  

