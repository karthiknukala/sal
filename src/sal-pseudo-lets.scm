;;
;; SAL 3.1, Copyright (C) 2006, 2011, SRI International.  All Rights Reserved.
;;
;; SAL is free software; you can redistribute it and/or 
;; modify it under the terms of the GNU General Public License 
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of 
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
;; GNU General Public License for more details. 
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software 
;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
;;

(module sal-pseudo-lets
        (include "sal.sch")
        (import sal-ast-copy sal-ast-env sal-ast-for-each sal-expression queue sal-ast-expand
                sal-assertion)
        (export (sal-ast/remove-pseudo-lets ast)
                (sal-flat-module/remove-pseudo-lets flat-module))
        )

;; - What is a pseudo let?
;;
;; A pseudo let is generated by IN definitions in the DEFINITION section.
;; Such defintions produce a <sal-definition-expression> node. This kind of
;; node creates problems for the symbolic model checker, since they cannot
;; be handled by substitution. 
(define (sal-flat-module/remove-pseudo-lets flat-module)
  (if (contains-pseudo-lets? flat-module)
    (let* ((_ (verbose-message 1 "removing pseudo lets (`in' simple selection from the definition section)...")) 
           (pseudo-lets-queue (make-queue))
           (new-definition (remove-and-collect-pseudo-lets (slot-value flat-module :definition) (make-empty-env) pseudo-lets-queue))
           (new-conjunct (apply make-sal-and (queue->list pseudo-lets-queue))))
      (copy-ast flat-module
                :definition new-definition
                :initialization (make-sal-and (slot-value flat-module :initialization) new-conjunct)
                :transition (make-sal-and (slot-value flat-module :transition) (sal-expr->next-expr new-conjunct (make-empty-env)))))
    flat-module))

(define (contains-pseudo-lets? flat-module)
  (sal-ast/find (lambda (ast)
                  (instance-of? ast <sal-definition-expression>))
                (slot-value flat-module :definition)))

(define-generic (remove-and-collect-pseudo-lets ast env pseudo-lets-queue))

(define-method (remove-and-collect-pseudo-lets (ast <sal-ast>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (sign-unsupported-feature ast "The following definition is not supported. This error is usually raised when complex IN statements are used in the definition section."))

(define-method (remove-and-collect-pseudo-lets (ast <sal-true>) (env <primitive>) (pseudo-lets-queue <primitive>))
  ast)

(define-method (remove-and-collect-pseudo-lets (ast <sal-eq>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (sal-ast/substitute ast env))

(define-method (remove-and-collect-pseudo-lets (ast <sal-not>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (sal-ast/substitute ast env))

(define-method (remove-and-collect-pseudo-lets (ast <sal-name-expr>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (sal-ast/substitute ast env))

(define-method (remove-and-collect-pseudo-lets (ast <sal-definition-expression>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (let ((expanded-ast (sal-ast/expand-names ast env))) ;; avoid problems with references to let-decls
    (queue/insert! pseudo-lets-queue expanded-ast)
    (make-sal-true ast)))

(define-method (remove-and-collect-pseudo-lets (ast <sal-and>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (let* ((arg-list (sal-application/argument-list ast))
         (new-arg-list (conservative-map-1 (cut remove-and-collect-pseudo-lets <> env pseudo-lets-queue) arg-list)))
    (if (eq? arg-list new-arg-list)
      ast
      (copy-ast ast
                :arg (apply make-application-argument new-arg-list)))))

(define-method (remove-and-collect-pseudo-lets (ast <sal-let-decl>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (update-ast-slots ast
                    :expr (remove-and-collect-pseudo-lets (slot-value ast :value) env pseudo-lets-queue)))

(define-method (remove-and-collect-pseudo-lets (ast <sal-let-expr>) (env <primitive>) (pseudo-lets-queue <primitive>))
  (let* ((local-decls (slot-value ast :local-decls))
         (new-local-decls (conservative-map-1 (cut remove-and-collect-pseudo-lets <> env pseudo-lets-queue) local-decls))
         (env (update-env* env local-decls new-local-decls)))
    (update-ast-slots ast
                      :local-decls new-local-decls
                      :expr (remove-and-collect-pseudo-lets (slot-value ast :expr) env pseudo-lets-queue))))

(define-generic (sal-ast/remove-pseudo-lets ast))
(define-method (sal-ast/remove-pseudo-lets (ast <sal-ast>))
  ast)
(define-method (sal-ast/remove-pseudo-lets (ast <sal-flat-module>))
  (sal-flat-module/remove-pseudo-lets ast))
(define-method (sal-ast/remove-pseudo-lets (assertion <sal-assertion-expr>))
  (sal-assertion/transformation-core assertion (make-empty-env)
                                     (lambda (module env)
                                       (sal-ast/remove-pseudo-lets module))))
