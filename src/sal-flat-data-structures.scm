;;
;; SAL 3.1, Copyright (C) 2006, 2011, SRI International.  All Rights Reserved.
;;
;; SAL is free software; you can redistribute it and/or 
;; modify it under the terms of the GNU General Public License 
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of 
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
;; GNU General Public License for more details. 
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software 
;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
;;

(module sal-flat-data-structures
        (include "sal.sch")
        (include "fast-hash-table.sch")
        (import queue sal-type sal-module sal-finite-expressions 
                symbol-table sal-ast-env gmp-scheme sal-flat-support sal-expression 
                sal-ast-simplify iterators sal-expr-evaluator
                unique-names sal-decls sal-pp sal-ast-copy runtime sal-component-info
                front-end sal-ast-for-each sal-ast-table sal-environment sal-ast-list
                sal-ast-expand sal-ast-eq)
        (export *sal-flat-finite-domain-functions*
                (sal/set-flat-finite-domain-functions! flag)
                (sal-ast/flat-data ast)
                (sal-type/num-atom-types type)
                (sal-type/flattenable? type)
                (sal-state-expr/flat-data expr env flat-module df-info)
                (make-sal-df-info . unint-types?)
                (make-sal-df-info-using flat-module)
                (data-list->sal-value type data-list)
                (populate-inv-flat-data-map! type decl-list expr inv-map)
                (flat-data-ast->ast ast env inv-map)
                (sal-expr/flat-data-core expr env aux-decl-queue df-info))
        )

;;--------------------------------------------------------------------
;;
;; Flat data structures
;;
;; Tuples & Records are flattened (breaken in pieces)
;;
;; (non-boolean) Scalars can be optionally converted to booleans
;;
;; Finite arrays can also be flattened (breaken in pieces)
;;
;;--------------------------------------------------------------------

;; REMARK: This module is very similar to sal-finite-expressions

;; A TYPE is said to be FLATTENABLE, when its values are broken in pieces by the flattener

;;
;; DESIGN DECISION
;;
;; Uninterpreted functions may create problems for the flattener.
;; For instance, consider the following uninterpreted function:
;;
;;       f : [ real -> { x : [real, real] | x.1 >= x.2 } ]
;;
;; A naive flattener would flatten this function as:
;;
;;       f!1 : real -> real
;;       f!2 : real -> real
;; 
;; In this case, the subtype constraint is missed (f(y).1 >= f(y).2).
;; To avoid this problem, we see three possible options
;;
;; 1) Hidden Axiom.
;;    We may associate an axiom with each function symbol. For instance,
;;    we would have the following axiom for f:
;;
;;     FORALL (x : real) : f(x).1 >= f(x).2 
;; 
;;    When, we apply the flattener over the axiom, we will produce the
;;    following new axiom:
;;
;;     FORALL (x : real) : f!1(x) >= f!2(x)
;;
;;    The problem in this solution are:
;;       - we have to carry these axioms
;;       - may be complicated to enforce them when generating the BMC formula.
;;         For instance, for the axiom above, I will have to instantiate the axiom
;;         for all pairs f!1(?X) and f!2(?X).
;;
;; 2) Disallow subtypes in the range of functions
;;    It is simple to implement, but may be too restrictive.
;;    Actually, this option is not that restrictive, since we are disallowing only
;;    subtypes of types that are flattenable. So, the following function type
;;    is still allowed:
;;   
;;    f : [ real -> { x : real | x > 3 }]
;;
;; I decided to implement option 2 since it is simpler than option 1, and our finite domain
;; solver will not require us to flatten data structures to obtain performace.
;; 
;; Sam suggestion: Allow subtypes of flattenable types, but print a warning
;;  message informing the user that the subtype constraint was ignored.
;;
;; I decided to use Sam suggestion.

;;
;; RESTRICTION
;;
;; - Global References
;;     only global references to <sal-auxiliary-decl> and uninterpreted constants
;;     is allowed. The other kind of references can be removed using sal-ast/expand.
;;     remark: <sal-auxiliary-decl> are generated by sal-ast/expand.
;;

;;--------------------------------------------------------------------
;; 
;; Configuration Flags
;;
;;--------------------------------------------------------------------

;; DESIGN DECISION
;;
;; I used to have an option called *sal-expand-scalar-values*... this
;; flag (when = true) forces the flattener to convert (non-boolean) scalar
;; values to sequences of boolean values. I believe this transformation
;; should not be implemented here, since it creates problems similar
;; to the ones related to subtypes and uninterpreted function symbols.
;; For instance, assume the following definitions:
;;  T : TYPE = {s1, s2, s3};
;;  f : [ BOOLEAN -> T ];
;;
;;  If *sal-expand-scalar-values* = #t, then the function f will be converted
;;  to
;;
;;  f!1 : [ BOOLEAN -> BOOLEAN ];
;;  f!2 : [ BOOLEAN -> BOOLEAN ];
;;
;; however, the assignment f!1(x)=TRUE, f!2(x)=TRUE is not valid, since in
;; our encoding the pair (TRUE,TRUE) doesn't correspond to any element of the
;; type T.
;;
;; Another advantage of not expanding scalar-values here is that I don't
;; need to keep track of invalid encondings (the slots :valid-state-expr, :valid-input-expr, etc.
;; like I did in the module sal-finite-expressions

(define *sal-flat-finite-domain-functions* #t) ;; break a finite array in pieces

(define (sal/set-flat-finite-domain-functions! flag)
  (set! *sal-flat-finite-domain-functions* flag))

(front-end/add-toggle-option! 
 "Extra Code Transformations" 
 "fdaf" 
 "finite domain array (function) flattening, that is, the conversion of a finite domain array (function) into a sequence of variables (default: enabled)."
 (lambda (flag)
   (set! *sal-flat-finite-domain-functions* flag)))

;;------------------------------------------------------------------------
;;
;; `Flattenable' types
;;
;; A type is "flattenable" if their values can be broken in smaller pieces.
;;
;;------------------------------------------------------------------------

(define-generic (sal-type/flattenable? type))
(define-method (sal-type/flattenable? (type <sal-type>))
  #t) ;; default behavior is flattenable
(define-method (sal-type/flattenable? (type <sal-scalar-type>))
  #f) ;; scalar type are never flattenable
(define-method (sal-type/flattenable? (type <sal-data-type>))
  #f) ;; datatypes are never flattenable
(define-method (sal-type/flattenable? (type <sal-subtype>))
  (sal-type/flattenable? (sal-subtype/immediate-super-type type)))
(define-method (sal-type/flattenable? (type <sal-function-type>))
  (or (and *sal-flat-finite-domain-functions*
           (sal-type/finite? (slot-value type :domain)))
      (sal-type/flattenable? (slot-value type :range))))
(define-method (sal-type/flattenable? (type <sal-type-name>))
  (and
   (not (sal-type/number? type)) ;; numbers are not flattenable
   (let ((body (sal-type-name/definition type)))
     (and body ;; only interpreted types can be flattened
          (sal-type/flattenable? body)))))

;;--------------------------------------------------------------------
;; 
;; sal-type/display-df-warnings
;;
;; Generate warning messages for possible incompleteness.
;; In the current version, a warning message is generated if
;; the subrange of a function uses a subtype of a flattenable type.
;;
;;--------------------------------------------------------------------
(define (sal-type/display-df-warnings type)
  (sal-ast/display-df-warnings-core type #f))

(define-generic (sal-ast/display-df-warnings-core ast in-range?))
(define-method (sal-ast/display-df-warnings-core (ast <sal-ast>) (in-range? <primitive>))
  #unspecified)
(define-method (sal-ast/display-df-warnings-core (ast <sal-type>) (in-range? <primitive>))
  ;; this method handles <sal-tuple-type>, <sal-record-type>, and <sal-data-type>
  (sal-ast/for-each-children (cut sal-ast/display-df-warnings-core <> in-range?) ast))
(define-method (sal-ast/display-df-warnings-core (ast <sal-scalar-type>) (in-range? <primitive>))
  #unspecified)
(define-method (sal-ast/display-df-warnings-core (ast <sal-field>) (in-range? <primitive>))
  (sal-ast/display-df-warnings-core (slot-value ast :type) in-range?))
(define-method (sal-ast/display-df-warnings-core (type <sal-subtype>) (in-range? <primitive>))
  (let ((super-type (sal-subtype/immediate-super-type type)))
    (when (and in-range? (sal-type/flattenable? super-type))
      (warning-message "A possible incompleteness can be introduced, because the supertype of the subtype at ~a will be flattened, and the subtype information (constraint) will be lost." (format-with-location type "")))
    (sal-ast/display-df-warnings-core super-type in-range?)))
(define-method (sal-ast/display-df-warnings-core (type <sal-function-type>) (in-range? <primitive>))
  ;; if I flatten the domain, then subtypes are ok, since the type enumerator will enforce the subtype constraints.
  (sal-ast/display-df-warnings-core (slot-value type :domain) #f)
  (sal-ast/display-df-warnings-core (slot-value type :range) #t))
(define-method (sal-ast/display-df-warnings-core (type <sal-type-name>) (in-range? <primitive>))
  (when (sal-type/flattenable? type)
    [assert (type) (sal-type-name/definition type)] ;; uninterpreted types are not flattenable
    (sal-ast/display-df-warnings-core (sal-type-name/definition type) in-range?)))
(define-method (sal-ast/display-df-warnings-core (type <sal-state-type>) (in-range? <primitive>))
  (sal-ast/display-df-warnings-core (sal-module/type (slot-value type :module)) in-range?))
(define-method (sal-ast/display-df-warnings-core (ast <sal-constructor>) (in-range? <primitive>))
  (let ((accessors (sal-name-expr/constructor-accessors ast)))
    (for-each (lambda (accessor)
                (sal-ast/display-df-warnings-core (sal-name-expr/accessor-type accessor) #f))
              accessors)))

;;
;; ****************** RESTRICTION **********************
;;
;; - I'm not supporting DATATYPES in this version.
;;   
;; Reason: the encoding of DATATYPES is really awkward in ICS.
;; In ICS, datatypes must be encoded as coproducts of tuples.
;; But, Harald says that tuples must be encoded using s-expressions in ICS?!?!
;; For instance, assume the following datatype:
;; Tree : TYPE = DATATYPE
;;                 node(data: Data, left_child : Tree, right_child : Tree),
;;                 leaf(data: Data)
;;               END
;;
;; The constructor "node(d,c1,c2)" is mapped to
;;   inl(cons(d,cons(c1,cons(c2,nil))))
;; The constructor "leaf(d)" is mapped to
;;   inr(cons(d,nil))   I could use "d", but I using lists here to maintain consistency
;;
;; The accessor "data(n)" is mapped to
;;   car(outl(n))
;; The accessor "left_child(n)" is mapped to
;;   car(cdr(outl(n)))
;; The accessor "right_child(n)" is mapped to
;;   car(cdr(cdr(outl(n))))
;; the recognizer "node?(n)" is mapped to
;;   inl(outl(n)) = n
;;
;; So, it is straightfoward to map SAL datatype expression to ICS expression,
;; but the reverse direction can be complicated, since ICS outputs a counterexample
;; model containing coproducts and s-expressions that do not have a counterpart in SAL.
;; So, the problem is how to map ICS expression using coproducts and s-expressions back to SAL
;; datatype expressions.
;;
;; I hope the new solver have a native support for datatypes, and this problem
;; can be avoided. By the way, CVC and CVC Lite support datatypes.


;;------------------------------------------------------------------------
;;
;; <sal-df-info>
;; 
;; Auxiliary data structure used by the flattener.
;; This data-structure stores global information that is collected/generated
;; by the flattener. 
;;
;; The slots
;;   :new-decl-table is a mapping (sal-ast-table) from qualified names to flattened declarations.
;;     I need this stuff because I must flatten uninterpreted constants. This table
;;     is used to guarantee that two different occurences of a constant are mapped to the
;;     same flattened new constant.
;;   :support-uninterpreted-types? is #t when the support for uninterpreted types is enabled.
;;
;; New slots may be added when I extend the functionality of this module.
;;
;; Remark: The flat-module must store the contents of the slot :new-decl-table
;; to be able to produce counterexamples using the original uinterpreted constants.
;;
;;------------------------------------------------------------------------

(define-class <sal-df-info> () (:new-decl-table :support-uninterpreted-types?))

(define (make-sal-df-info . unint-types?)
  (let ((unint-types? (optional-arg unint-types? #t)))
    (make-instance <sal-df-info>
                   :new-decl-table (make-sal-ast-table)
                   :support-uninterpreted-types? unint-types?)))
  
(define (make-sal-df-info-using flat-module)
  [assert (flat-module) (instance-of? flat-module <sal-simple-data-flat-module>)]
  (make-instance <sal-df-info>
                 :new-decl-table (slot-value flat-module :const-trace-info)
                 :support-uninterpreted-types? #t))

;; flat an uninterpreted constant, the flattened declarations are inserted in an auxiliary context.
;; the table :new-decl-table is used to memoize the flattened declarations associated with the cnst-name.
;; the result is a list of flattened names.
(define (sal-df-info/flat-uninterpreted-constant df-info cnst-name env)
  ;; (breakpoint "sal-df-info/flat-uninterpreted-constant" (df-info cnst-name env) #t)
  (let* ((aux-ctx (sal-env/auxiliary-context (sal-ast/sal-env cnst-name)))
         (decl-list (cond
                     ((sal-ast-table/get (slot-value df-info :new-decl-table) cnst-name) =>
                      cdr)
                     (else
                      [assert (cnst-name) (instance-of? (slot-value cnst-name :decl) <sal-constant-decl>)]
                      (let* ((type (sal-expr/type cnst-name))
                             (_ (sal-type/display-df-warnings type)) ;; generate warning messages when necessary
                             (base-name (sal-name-ref/name cnst-name))
                             (source-decl (slot-value cnst-name :decl))
                             (decl-list (sal-type->flattened-var-decls type base-name source-decl env df-info)))
                        (for-each (lambda (decl)
                                    (queue/insert! (slot-value aux-ctx :declarations) decl))
                                  decl-list)
                        (sal-ast-table/put! (slot-value df-info :new-decl-table) cnst-name decl-list)
                        decl-list)))))
    (map (lambda (decl)
           (copy-ast cnst-name
                     :decl decl
                     :context-ref aux-ctx
                     :actuals '()))
         decl-list)))

;;------------------------------------------------------------------------
;;
;; sal-type->flattened-var-decls
;;
;; convert a type in a list of flattened var-decls
;; Arguments:
;;  - type (type to be converted)
;;  - base-name (name to be used in the new var-decl)
;;  - source (the original var-decl that is being processed)
;;       provides place information, and instance class
;;  - env (sal-ast-env, that is, a mapping from decl -> decl-list)
;;        remark: the mapping is implemented as a balanced tree.
;;                I used balanced trees because I wanted to use a functional data 
;;                structure.
;;  - new-decl-table (mapping from qualified names to flattened declarations)
;;       I need this stuff because I must process the slot :expr of subtypes.
;;       In a future version, this slot will also be used to process <sal-data-type>
;;       remark: the mapping is implemented as hashtable
;; Result:
;;  - a list of var-decls which contains only non-flattenable types.
;;------------------------------------------------------------------------

(define-generic (sal-type->flattened-var-decls type base-name source env df-info))

(define (maintain-atomic-type type base-name source)
  (let* ((place-provider source)
         (new-id (make-sal-identifier place-provider base-name)))
    (list (copy-ast source
                    :id new-id
                    :type type))))

(define-method (sal-type->flattened-var-decls (type <sal-type>) (base-name <primitive>) (source <primitive>) (env <primitive>) (df-info <sal-df-info>))
  (maintain-atomic-type type base-name source))

(define-method (sal-type->flattened-var-decls (type <sal-state-type>) (base-name <primitive>) (source <primitive>) (env <primitive>) 
                                              (df-info <sal-df-info>))
  (sal-type->flattened-var-decls (sal-module/type (slot-value type :module)) base-name source env df-info))

(define-method (sal-type->flattened-var-decls (type <sal-type-name>) (base-name <primitive>) (source <primitive>) (env <primitive>) 
                                              (df-info <sal-df-info>))
  (let ((definition (sal-type-name/definition type)))
    (if definition
      (cond
       ((or (sal-type/number? definition)
            (instance-of? definition <sal-scalar-type>))
        (maintain-atomic-type type base-name source))
       ((instance-of? definition <sal-data-type>)
        (sign-unsupported-feature type "Failed to flatten data structures, datatypes are not supported in the current version."))
       (else
        (sal-type->flattened-var-decls definition base-name source env df-info)))
      ;; maintain uninterpreted types
      (if (slot-value df-info :support-uninterpreted-types?)
        (maintain-atomic-type type base-name source)
        (sign-unsupported-feature type "Uninterpreted types are not supported by this tool.")))))

(define-method (sal-type->flattened-var-decls (type <sal-subtype>) (base-name <primitive>) (source <primitive>) (env <primitive>) 
                                              (df-info <sal-df-info>))
  (cond
   ((sal-type/number? type)
    ;; fix a problem with subtypes identified by Bruno... 
    (let* ((pred (slot-value type :expr))
           (aux-decl-queue (make-queue))
           (new-body-list (sal-expr/flat-data-core pred env aux-decl-queue df-info))
           (new-pred (begin
                       [assert (new-body-list) (= (length new-body-list) 1)]
                       (make-sal-let-expr (queue->list aux-decl-queue)
                                          (car new-body-list))))
           (new-type (copy-ast type
                               :expr new-pred)))
      (maintain-atomic-type new-type base-name source)))
   ((sal-type/flattenable? type)
    ;; approximation... the sal-type/display-df-warnings will print warning messages when this approximation produces incompletenesses
    (sal-type->flattened-var-decls (sal-subtype/immediate-super-type type) base-name source env df-info))
   (else
    (let* ((normalized-subtype (sal-subtype/normalize type))
           (pred (slot-value normalized-subtype :expr)))
      [assert (pred) (instance-of? pred <sal-lambda>)]
      [assert (pred) (= (length (slot-value pred :local-decls)) 1)]
      (let* ((var-decl (car (slot-value pred :local-decls)))
             (vtype (slot-value var-decl :type))
             (body (slot-value pred :expr))
             (flattened-var-decl-list (sal-type->flattened-var-decls vtype base-name var-decl env df-info))
             (_ [assert (flattened-var-decl-list) (= (length flattened-var-decl-list) 1)])
	     (new-env (update-env env var-decl flattened-var-decl-list))
             (aux-decl-queue (make-queue))
             (new-body-list (sal-expr/flat-data-core body new-env aux-decl-queue df-info))
             (new-body (begin [assert (new-body-list) (= (length new-body-list) 1)]
                              (make-sal-let-expr (queue->list aux-decl-queue)
                                                 (car new-body-list))))
             (new-pred (copy-ast pred
                                 :local-decls flattened-var-decl-list
                                 :expr new-body))
             (new-type (copy-ast type
                                 :expr new-pred)))
        (maintain-atomic-type new-type base-name source))))))

(define-method (sal-type->flattened-var-decls (type <sal-tuple-type>) (base-name <primitive>) (source <primitive>) (env <primitive>)
                                              (df-info <sal-df-info>))
  (let ((idx 1)
        (var-decl-queue (make-queue)))
    (for-each (lambda (type)
                (let ((new-var-decls (sal-type->flattened-var-decls type (symbol-append base-name '! (object->symbol idx)) source env df-info)))
                  (set! idx (+ idx 1))
                  (queue/append! var-decl-queue new-var-decls)))
              (sal-tuple-type/types type))
    (queue->list var-decl-queue)))

(define-method (sal-type->flattened-var-decls (type <sal-record-type>) (base-name <primitive>) (source <primitive>) (env <primitive>) 
                                              (df-info <sal-df-info>))
  (let ((var-decl-queue (make-queue)))
    (for-each (lambda (field)
                (let* ((field-type (slot-value field :type))
                       (field-name (sal-identifier/name (slot-value field :id)))
                       (new-var-decls (sal-type->flattened-var-decls field-type (symbol-append base-name '! field-name) source env df-info)))
                  (queue/append! var-decl-queue new-var-decls)))
              (sal-record-type/fields type))
    (queue->list var-decl-queue)))

(define (sal-funtion-type->flattened-var-decl-default type base-name source env df-info)
  [assert (type) (instance-of? type <sal-function-type>)]
  (let* ((domain (slot-value type :domain))
         (range (slot-value type :range))
         (domain-flattened-var-decls (sal-type->flattened-var-decls domain base-name source env df-info))
         (range-flattened-var-decls (sal-type->flattened-var-decls range base-name source env df-info))
         (new-domain (if (= (length domain-flattened-var-decls) 1)
                       (slot-value (car domain-flattened-var-decls) :type)
                       (make-ast-instance <sal-domain-tuple-type> domain
                                          :types (map (cut slot-value <> :type) domain-flattened-var-decls)))))
    (map (lambda (range-var-decl)
           (copy-ast range-var-decl
                     :type (copy-ast type
                                     :domain new-domain
                                     :range (slot-value range-var-decl :type))))
         range-flattened-var-decls)))

(define (compute-domain-num-elems type)
  (let ((domain (sal-function-type/domain type)))
    (unless (sal-type/finite? domain)
      (sign-unsupported-feature type "Function (array) type cannot be flattened, domain is not finite."))
    (try
     (sal-type/number-of-elements-as-integer domain)
     (catch 'sal-type-number-of-elements
            (lambda (m)
              (sign-unsupported-feature type "Function (array) type cannot be flattened because it was not possible to compute the number of elements in the domain (reason: ~a)" m))))))
         
(define (sal-funtion-type->flattened-var-decl-with-flat-domain type base-name source env df-info)
  (let* ((domain-num-elems (compute-domain-num-elems type))
         (range (sal-function-type/range type))
         (range-var-decls (sal-type->flattened-var-decls range (string->symbol "") source env df-info))
         (var-decl-queue (make-queue)))
    (let loop ((idx 0))
      (when (< idx domain-num-elems)
        (for-each (lambda (range-var-decl)
                    (let* ((suffix (sal-decl/name range-var-decl))
                           (new-name (symbol-append base-name '! (object->symbol idx) suffix))
                           (place-provider range-var-decl)
                           (new-id (make-sal-identifier place-provider new-name))
                           (new-var-decl (copy-ast range-var-decl :id new-id)))
                      (queue/insert! var-decl-queue new-var-decl)))
                  range-var-decls)
        (loop (+ idx 1))))
    (queue->list var-decl-queue)))

(define-method (sal-type->flattened-var-decls (type <sal-function-type>) (base-name <primitive>) (source <primitive>) (env <primitive>) 
                                              (df-info <sal-df-info>))
  (if (and *sal-flat-finite-domain-functions* 
           (sal-type/finite? (slot-value type :domain)))
    (sal-funtion-type->flattened-var-decl-with-flat-domain type base-name source env df-info)
    (sal-funtion-type->flattened-var-decl-default type base-name source env df-info)))

(define (sal-var-decl->sal-flattened-var-decls var-decl env df-info)
  (let ((base-name (sal-decl/name var-decl)))
    (sal-type->flattened-var-decls (slot-value var-decl :type) base-name var-decl env df-info)))

;; Convert a list of variable declarations in a list of flat variable declarations.
;; Two values are returned:
;;  1) a list of flat declarations
;;  2) a list of list of flat declarations
;; For example, the list [x::(tuple nat bool), y::(tuple bool bool)]
;; is mapped to:
;;  1) (x!1::nat x!2::bool y!1::bool y!2::bool)
;;  2) ((x!1::nat x!2::bool) (y!1::bool y!2::bool))
(define (sal-var-decls->sal-flattened-var-decls var-decl-list env df-info)
  (let ((flat-var-decl-queue (make-queue))
        (flat-var-decl-list-queue (make-queue)))
    (for-each (lambda (var-decl)
                (let ((flat-var-decls (sal-var-decl->sal-flattened-var-decls var-decl env df-info)))
                  (queue/append! flat-var-decl-queue flat-var-decls)
                  (queue/insert! flat-var-decl-list-queue flat-var-decls)))
              var-decl-list)
    (values (queue->list flat-var-decl-queue)
            (queue->list flat-var-decl-list-queue))))


;;--------------------------------------------------------------------
;;
;; Type number of atomic types
;;
;;--------------------------------------------------------------------
(define-generic (sal-type/num-atom-types type))

(define-method (sal-type/num-atom-types (type <sal-type>))
  1)

(define-method (sal-type/num-atom-types (type <sal-state-type>))
  (sal-type/num-atom-types (sal-module/type (slot-value type :module))))

(define-method (sal-type/num-atom-types (type <sal-subtype>))
  (if (sal-type/flattenable? type)
    (sal-type/num-atom-types (sal-subtype/immediate-super-type type))
    1))

(define-method (sal-type/num-atom-types (type <sal-type-name>))
  (if (sal-type/flattenable? type)
    (let ((definition (sal-type-name/definition type)))
      [assert (type definition) definition] ;; a flattenable must have an interpretation
      (sal-type/num-atom-types definition))
    1))

(define-method (sal-type/num-atom-types (type <sal-tuple-type>))
  (fold-left (lambda (curr child-type)
               (+ curr (sal-type/num-atom-types child-type)))
             0
             (sal-tuple-type/types type)))

(define-method (sal-type/num-atom-types (type <sal-record-type>))
  (fold-left (lambda (curr entry)
               (+ curr (sal-type/num-atom-types (slot-value entry :type))))
             0
             (sal-record-type/fields type)))

(define-method (sal-type/num-atom-types (type <sal-function-type>))
  (if (and *sal-flat-finite-domain-functions* 
           (sal-type/finite? (slot-value type :domain)))
    (let* ((domain-num-elems (compute-domain-num-elems type))
           (range (slot-value type :range))
           (range-num-elems (sal-type/num-atom-types range)))
      (* domain-num-elems range-num-elems))
    (sal-type/num-atom-types (slot-value type :range))))

;;------------------------------------------------------------------------
;;
;; sal-expr/flat-data-core
;;
;;------------------------------------------------------------------------

(define-generic (sal-expr/flat-data-core expr env aux-decl-queue df-info))

(define-method (sal-expr/flat-data-core (expr <sal-expr>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sign-source-error expr "Failed to flatten data structures, this kind of expression is not supported by the translator."))

(define-method (sal-expr/flat-data-core (expr <sal-numeral>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (list expr))

(define-method (sal-expr/flat-data-core (expr <sal-scalar>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (list expr))

(define-method (sal-expr/flat-data-core (expr <sal-name-expr>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (cond
   ((lookup-env (slot-value expr :decl) env) =>
    (lambda (decl-list)
      [assert (expr) (not (instance-of? expr <sal-qualified-name-expr>))]
      [assert (decl-list) (for-all (cut instance-of? <> <sal-decl>) decl-list)]
      (map (lambda (decl) (copy-ast expr :decl decl)) decl-list)))
   ((sal-name-expr/definition expr) =>
    (lambda (definition)
      (sal-expr/flat-data-core definition env aux-decl-queue df-info)))
   (else
;;    (breakpoint "flat name-expr" (expr env df-info) #t)
    (internal-error))))

(define-method (sal-expr/flat-data-core (expr <sal-qualified-name-expr>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (cond
   ((sal-name-expr/definition expr) =>
    (lambda (definition) 
      (sal-expr/flat-data-core definition env aux-decl-queue df-info)))
   (else 
    ;; uninterpreted constant
    (sal-df-info/flat-uninterpreted-constant df-info expr env))))


(define-method (sal-expr/flat-data-core (expr <sal-next-operator>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  [assert (expr) (instance-of? (slot-value expr :name-expr) <sal-name-expr>)]
  (let ((name-expr-list (sal-expr/flat-data-core (slot-value expr :name-expr) env aux-decl-queue df-info)))
    (map (lambda (name)
           (copy-ast expr
                     :name-expr name))
         name-expr-list)))

(define-method (sal-expr/flat-data-core (expr <sal-propositional-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sal-flattener/keep-application expr (cut sal-expr/flat-data-core <> env aux-decl-queue df-info)))

(define-method (sal-expr/flat-data-core (expr <sal-temporal-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sal-flattener/keep-application expr (cut sal-expr/flat-data-core <> env aux-decl-queue df-info)))

(define-method (sal-expr/flat-data-core (expr <sal-arith-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sal-flattener/keep-application expr (cut sal-expr/flat-data-core <> env aux-decl-queue df-info)))

(define (sal-eq->flat-data-expr-core expr env eq-proc combine-proc aux-decl-queue df-info)
  (multiple-value-bind 
      (arg1 arg2)
      (sal-binary-application/arguments expr)
    (let ((arg1-list (sal-expr/flat-data-core arg1 env aux-decl-queue df-info))
          (arg2-list (sal-expr/flat-data-core arg2 env aux-decl-queue df-info)))
      [sal-assert "sal-eq->flat-data-expr-core" (expr env arg1-list arg2-list) (= (length arg1-list) (length arg2-list))]
      (list (apply combine-proc (map (lambda (data1 data2)
                                       (eq-proc data1 data2))
                                     arg1-list
                                     arg2-list))))))

(define (sal-eq->flat-data-expr-default expr env aux-decl-queue df-info)
  (let ((place-provider expr))
    (sal-eq->flat-data-expr-core expr env
                                 (lambda (arg1 arg2)
                                   (copy-ast expr
                                             :arg (make-application-argument arg1 arg2)))
                                 (lambda args
                                   (make-sal-and+* args place-provider))
                                 aux-decl-queue
                                 df-info)))

(define-method (sal-expr/flat-data-core (expr <sal-eq>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sal-eq->flat-data-expr-default expr env aux-decl-queue df-info))

(define-method (sal-expr/flat-data-core (expr <sal-assignment>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (multiple-value-bind
      (lhs rhs)
      (sal-binary-application/arguments expr)
    (cond
     ((sal-lhs/ground? lhs)
      (sal-eq->flat-data-expr-default expr env aux-decl-queue df-info))
     (else 
      ;; the lhs is not ground... so, I convert the assignment to a definition-expression, and 
      ;; call sal-expr/flat-data-core again
      (let ((def-expr (make-ast-instance <sal-definition-expression> expr
                                         :lhs-list (list lhs)
                                         :expr (change-ast-class expr <sal-eq>))))
        (sal-expr/flat-data-core def-expr env aux-decl-queue df-info))))))

(define-method (sal-expr/flat-data-core (expr <sal-diseq>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sal-eq->flat-data-expr-core expr env
                                (lambda (arg1 arg2)
                                  (copy-ast expr
                                            :arg (make-application-argument arg1 arg2)))
                                (lambda args
                                  (if (null? args)
                                    (make-sal-false expr)
                                    (apply make-sal-or+ args)))
                                aux-decl-queue
                                df-info))

(define-method (sal-expr/flat-data-core (expr <sal-conditional>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let* ((cond-list (sal-expr/flat-data-core (slot-value expr :cond-expr) env aux-decl-queue df-info))
         (then-list (sal-expr/flat-data-core (slot-value expr :then-expr) env aux-decl-queue df-info))
         (else-list (sal-expr/flat-data-core (slot-value expr :else-expr) env aux-decl-queue df-info))
         (place-provider expr)
         (cond-expr (make-expr-alias! (car cond-list)
                                      aux-decl-queue
                                      'cond)))
    [assert (cond-list) (= (length cond-list) 1)]
    [assert (expr then-list else-list) (= (length then-list) (length else-list))]
    (map (lambda (then-expr else-expr)
           (make-sal-cond+ cond-expr then-expr else-expr place-provider))
         then-list
         else-list)))


(define-method (sal-expr/flat-data-core (expr <sal-tuple-literal>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((result-queue (make-queue)))
    (for-each (lambda (curr-expr)
                (queue/append! result-queue (sal-expr/flat-data-core curr-expr env aux-decl-queue df-info)))
              (slot-value expr :exprs))
    (queue->list result-queue)))

(define-method (sal-expr/flat-data-core (expr <sal-record-literal>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((result-queue (make-queue)))
    (for-each (lambda (entry)
                (let ((entry-list (sal-expr/flat-data-core (slot-value entry :expr) env aux-decl-queue df-info)))
                  (queue/append! result-queue entry-list)))
              (slot-value expr :entries))
    (queue->list result-queue)))

(define (sal-lambda/flat-data-core expr env aux-decl-queue df-info)
  (let ((local-decls (slot-value expr :local-decls)))
    (multiple-value-bind
        (new-local-decls new-local-decls-groups)
        (sal-var-decls->sal-flattened-var-decls local-decls env df-info)
      (let* ((new-env (update-env* env local-decls new-local-decls-groups))
             (nested-exprs (sal-expr/flat-data-core (slot-value expr :expr) new-env aux-decl-queue df-info))
             (removed-let-decls (remove-dependent-aux-let-decls! aux-decl-queue new-local-decls))
             (new-nested-exprs (map (cut make-sal-let-expr removed-let-decls <>) nested-exprs)))
        (map (lambda (new-nested-expr)
               (copy-ast expr
                         :local-decls new-local-decls
                         :expr new-nested-expr))
             new-nested-exprs)))))

(define (sal-lambda/flat-data-with-finite-domain expr env aux-decl-queue df-info)
  (try
   (let* ((fun-type (sal-expr/type expr))
          (domain (sal-function-type/domain fun-type))
          (it (sal-type/make-iterator domain))
          (result-queue (make-queue)))
     (iterator/for-each (lambda (domain-value)
                          (let* ((range-value (sal-ast/simplify (sal-expr/apply expr domain-value)))
                                 (range-value-list (sal-expr/flat-data-core range-value env aux-decl-queue df-info)))
                            (queue/append! result-queue range-value-list)))
                        it)
     (queue->list result-queue))
   (catch 'type-iterator
          (lambda (msg)
            (sign-unsupported-feature expr "Failed to flatten data structure in function (or array), reason: ~a" msg)))))

(define-method (sal-expr/flat-data-core (expr <sal-lambda>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((fun-type (sal-expr/type expr)))
    (if (and *sal-flat-finite-domain-functions*
             (sal-type/finite? (sal-function-type/domain fun-type)))
      (sal-lambda/flat-data-with-finite-domain expr env aux-decl-queue df-info)
      (sal-lambda/flat-data-core expr env aux-decl-queue df-info))))

(define-method (sal-expr/flat-data-core (expr <sal-tuple-selection>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let* ((expr-list (sal-expr/flat-data-core (slot-value expr :target) env aux-decl-queue df-info))
         (pos (- (sal-tuple-position->integer (slot-value expr :idx)) 1))
         (tuple-type (sal-expr/type (slot-value expr :target)))
         (type-list (sal-tuple-type/types tuple-type)))
    (let loop ((i 0)
               (type-list type-list)
               (expr-list expr-list))
      (when (null? type-list)
        (sign-source-error expr "Invalid tuple selection."))
      (let* ((curr-type (car type-list))
             (curr-num-atoms (sal-type/num-atom-types curr-type)))
        (if (= i pos)
          (list-head expr-list curr-num-atoms)
          (loop (+ i 1) (cdr type-list) (list-tail expr-list curr-num-atoms)))))))

(define-method (sal-expr/flat-data-core (expr <sal-record-selection>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let* ((expr-list (sal-expr/flat-data-core (slot-value expr :target) env aux-decl-queue df-info))
         (field-name (slot-value (slot-value expr :idx) :name))
         (record-type (sal-expr/type (slot-value expr :target)))
         (field-list (sal-record-type/fields record-type)))
    (let loop ((field-list field-list)
               (expr-list expr-list))
      (when (null? field-list)
        (sign-source-error expr "Invalid record selection."))
      (let* ((curr-field (car field-list))
             (curr-type (slot-value curr-field :type))
             (curr-num-atoms (sal-type/num-atom-types curr-type))
             (curr-field-name (slot-value (slot-value curr-field :id) :name)))
        (if (eq? curr-field-name field-name)
          (list-head expr-list curr-num-atoms)
          (loop (cdr field-list) (list-tail expr-list curr-num-atoms)))))))

(define (evaluate-or-false expr)
  (try
   (sal-expr/evaluate expr)
   (catch 'expr-evaluator
          (lambda (_)
            #f))))

(define (sal-function-application->flat-data-expr-default expr env aux-decl-queue df-info)
   (let* ((fun (slot-value expr :fun))
          (fun-value-list (sal-expr/flat-data-core fun env aux-decl-queue df-info))
          (arg (slot-value expr :arg))
          (arg-value-list (sal-expr/flat-data-core arg env aux-decl-queue df-info)))
     [assert (fun-value-list arg-value-list expr) (for-all (lambda (fun-value)
                                                             (let* ((fun-value-type (sal-expr/type fun))
                                                                    (arity (sal-function-type/arity fun-value-type)))
                                                               (= arity (length arg-value-list)))))]
     (map (lambda (fun-value)
            (copy-ast expr
                      :fun fun-value
                      :arg (apply make-application-argument arg-value-list)))
          fun-value-list)))

(define (sal-function-application->flat-data-expr-with-finite-domain expr env aux-decl-queue df-info)
  (try
   (let* ((fun (slot-value expr :fun))
          (fun-type (sal-expr/type fun))
          (fun-value-list (sal-expr/flat-data-core fun env aux-decl-queue df-info))
          (domain (sal-function-type/domain fun-type))
          (range (sal-function-type/range fun-type))
          (range-num-atoms (sal-type/num-atom-types range))
          (it (sal-type/make-iterator domain))
          (arg (evaluate-or-false (slot-value expr :arg))))
     (unless (iterator/has-next? it)
       (sign-source-error (slot-value expr :fun) "Invalid function (or array), the domain is empty."))
     (with-output-to-trace 'flat-data 
                           (print "function application: ")
                           (sal/pp expr)
                           (print "\nfun-value-list:")
                           (sal/pp fun-value-list)
                           (print "\n---------------"))
     (if (and arg (sal-expr/first-order-value? arg))
       (let ((value-idx (sal-type/value-idx domain arg)))
         (if (not value-idx)
           (sign-unsupported-feature expr "Failed to convert function application (array selection). The function/array does not have a finite domain, or the argument is not in the domain of the function/array.")
           (list-head (list-tail fun-value-list (* value-idx range-num-atoms)) range-num-atoms)))
       ;; generate expensive representation
       (let ((arg-value-list (sal-expr/flat-data-core (slot-value expr :arg) env aux-decl-queue df-info))
             (result-list (list-head fun-value-list range-num-atoms)))
         (set! fun-value-list (list-tail fun-value-list range-num-atoms))
         (iterator/next! it)
         (iterator/for-each 
          (lambda (domain-value)
            (with-output-to-trace 'flat-data 
                                  (print "domain-value:")
                                  (sal/pp domain-value)
                                  (print "\nfun-value-list:")
                                  (sal/pp fun-value-list)
                                  (print "\n---------------"))
            (let* ((domain-value-list (sal-expr/flat-data-core domain-value env aux-decl-queue df-info))
                   (_ [assert (arg-value-list domain-value-list expr env) (= (length arg-value-list) (length domain-value-list))])
                   (place-provider expr)
                   (condition (make-bool-expr-alias! (make-sal-and+* (map (lambda (arg-val dom-val)
                                                                            (make-sal-equality+ arg-val dom-val))
                                                                          arg-value-list
                                                                          domain-value-list)
                                                                     place-provider)
                                                     aux-decl-queue
                                                     'cond))
                   (next-value-list (list-head fun-value-list range-num-atoms))
                   (__ [assert (result-list fun-value-list range-num-atoms next-value-list expr env) (= (length result-list) (length next-value-list))])
                   (new-result-list (map (lambda (curr-value next-value)
                                           (make-sal-cond+ condition next-value curr-value expr)) 
                                         result-list
                                         next-value-list)))
              (set! result-list new-result-list)
              (set! fun-value-list (list-tail fun-value-list range-num-atoms))))
          it)
         result-list)))
   (catch 'type-iterator
          (lambda (msg)
            (sign-unsupported-feature expr "Failed to flatten data structures in function application (or array selection), reason: ~a" msg)))))

(define (sal-function-application->flat-data-expr-core expr env aux-decl-queue df-info)
  (let* ((fun (slot-value expr :fun))
         (fun-type (sal-expr/type fun))
         (domain (sal-function-type/domain fun-type)))
    (if (and *sal-flat-finite-domain-functions*
             (sal-type/finite? domain))
      (sal-function-application->flat-data-expr-with-finite-domain expr env aux-decl-queue df-info)
      (sal-function-application->flat-data-expr-default expr env aux-decl-queue df-info))))

(define-method (sal-expr/flat-data-core (expr <sal-array-selection>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sal-function-application->flat-data-expr-core expr env aux-decl-queue df-info))

(define (sign-unsupported-data-type-operation expr)
  (sign-unsupported-feature expr "Failed to flatten data structures in the expression. The current version of SALenv does not support datatype operations."))

(define-method (sal-expr/flat-data-core (expr <sal-constructor-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sign-unsupported-data-type-operation expr))

(define-method (sal-expr/flat-data-core (expr <sal-recognizer-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sign-unsupported-data-type-operation expr))

(define-method (sal-expr/flat-data-core (expr <sal-accessor-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sign-unsupported-data-type-operation expr))

(define-method (sal-expr/flat-data-core (expr <sal-debug-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sal-expr/flat-data-core (list-last-element (sal-application/argument-list expr)) env aux-decl-queue df-info))

(define-method (sal-expr/flat-data-core (expr <sal-application>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((fun (slot-value expr :fun)))
    (if (and (instance-of? fun <sal-name-expr>)
             (instance-of? (slot-value fun :decl) <sal-auxiliary-decl>))
      (let ((new-expr (sal-ast/simplify (sal-expr/apply (slot-value (slot-value fun :decl) :value) (slot-value expr :arg)))))
        (sal-expr/flat-data-core new-expr env aux-decl-queue df-info))
      (sal-function-application->flat-data-expr-core expr env aux-decl-queue df-info))))

(define-method (sal-expr/flat-data-core (expr <sal-definition-expression>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((defined-lhs-list (slot-value expr :lhs-list)))
    (unless (= (length defined-lhs-list) 1)
      ;; I should check this restriction...
      (sign-unsupported-feature expr "Defined expression contains more than one defined left-hand-side, so it cannot be flattened."))
    (let ((lhs-value-list (sal-expr/flat-data-core (car defined-lhs-list) env aux-decl-queue df-info))
          (expr-value-list (sal-expr/flat-data-core (slot-value expr :expr) env aux-decl-queue df-info)))
      [assert (expr-value-list) (= (length expr-value-list) 1)]
      (list (copy-ast expr
                      :lhs-list lhs-value-list
                      :expr (car expr-value-list))))))

(define-method (sal-expr/flat-data-core (expr <sal-let-expr>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let* ((local-decls (slot-value expr :local-decls))
         (local-decls-groups
          (map (lambda (local-decl)
                 (let* ((curr-value-list (sal-expr/flat-data-core (slot-value local-decl :value) env aux-decl-queue df-info))
                        (new-decls (map (lambda (curr-value)
                                          (let* ((new-name (gen-unique-name (sal-decl/name local-decl)))
                                                 (new-id (copy-ast (slot-value local-decl :id) 
                                                                   :name new-name))
                                                 (new-decl (copy-ast local-decl
                                                                     :id new-id
                                                                     :type (sal-expr/type curr-value)
                                                                     :value curr-value)))
                                            ;; [breakpoint "sal-expr/flat-data-core" (curr-value) (and (instance-of? curr-value <sal-mul>))] 
                                            new-decl))
                                        curr-value-list)))
                   (queue/append! aux-decl-queue new-decls)
                   new-decls))
               local-decls))
         (new-env (update-env* env local-decls local-decls-groups)))
    (sal-expr/flat-data-core (slot-value expr :expr) new-env aux-decl-queue df-info)))

(define-method (sal-expr/flat-data-core (expr <sal-tuple-update>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((tuple-value-list (sal-expr/flat-data-core (slot-value expr :target) env aux-decl-queue df-info))
        (new-value-list (sal-expr/flat-data-core (slot-value expr :new-value) env aux-decl-queue df-info))
        (pos (- (sal-tuple-position->integer (slot-value expr :idx)) 1))
        (type-list (sal-tuple-type/types (sal-expr/type expr)))
        (result-value-queue (make-queue)))
    (let loop ((i 0)
               (type-list type-list)
               (tuple-value-list tuple-value-list))
      (when (null? type-list)
        (sign-source-error expr "Invalid tuple update."))
      (let* ((curr-type (car type-list))
             (curr-num-atoms (sal-type/num-atom-types curr-type))
             (rest-tuple-value-list (list-tail tuple-value-list curr-num-atoms))
             (rest-type-list (cdr type-list)))
        (cond
         ((= i pos)
          [assert (new-value-list curr-num-atoms) (= (length new-value-list) curr-num-atoms)]
          (queue/append! result-value-queue new-value-list)
          (queue/append! result-value-queue rest-tuple-value-list)
          (queue->list result-value-queue))
         (else
          (let ((curr-value-list (list-head tuple-value-list curr-num-atoms)))
            (queue/append! result-value-queue curr-value-list)
            (loop (+ i 1) rest-type-list rest-tuple-value-list))))))))

(define-method (sal-expr/flat-data-core (expr <sal-record-update>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((record-value-list (sal-expr/flat-data-core (slot-value expr :target) env aux-decl-queue df-info))
        (new-value-list (sal-expr/flat-data-core (slot-value expr :new-value) env aux-decl-queue df-info))
        (field-name (slot-value (slot-value expr :idx) :name))
        (field-list (sal-record-type/fields (sal-expr/type expr)))
        (result-value-queue (make-queue)))
    (let loop ((field-list field-list)
               (record-value-list record-value-list))
      (when (null? field-list)
        (sign-source-error expr "Invalid record update."))
      (let* ((curr-field (car field-list))
             (curr-type (slot-value curr-field :type))
             (curr-num-atoms (sal-type/num-atom-types curr-type))
             (curr-field-name (slot-value (slot-value curr-field :id) :name))
             (rest-record-value-list (list-tail record-value-list curr-num-atoms))
             (rest-field-list (cdr field-list)))
        (cond
         ((eq? field-name curr-field-name)
          (queue/append! result-value-queue new-value-list)
          (queue/append! result-value-queue rest-record-value-list)
          (queue->list result-value-queue))
         (else
          (let ((curr-value-list (list-head record-value-list curr-num-atoms)))
            (queue/append! result-value-queue curr-value-list)
            (loop rest-field-list rest-record-value-list))))))))

(define-method (sal-expr/flat-data-core (expr <sal-function-update>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (sign-unsupported-feature expr 
                            "Function sal-expr/flat-data-core cannot handle <sal-function-update> instances. Use sal-ast/simplify to remove them."))

(define (sal-array-update/flat-data-core expr env aux-decl-queue df-info)
   (let ((array-value-list (sal-expr/flat-data-core (slot-value expr :target) env aux-decl-queue df-info))
         (new-value-list (sal-expr/flat-data-core (slot-value expr :new-value) env aux-decl-queue df-info))
         (new-idx-list (sal-expr/flat-data-core (slot-value expr :idx) env aux-decl-queue df-info)))
     (unless (= (length new-idx-list) 1)
       (sign-source-error expr "Index of array must be a number or a scalar value."))
     [assert (array-value-list new-idx-list) (= (length array-value-list) (length new-value-list))]
     (map (lambda (array-value new-value)
            (copy-ast expr
                      :target array-value
                      :idx (car new-idx-list)
                      :new-value new-value))
          array-value-list
          new-value-list)))
  
(define (sal-array-update/flat-data-with-finite-domain expr env aux-decl-queue df-info)
  (try
   (let* ((array-value-list (sal-expr/flat-data-core (slot-value expr :target) env aux-decl-queue df-info))
          (new-value-list (sal-expr/flat-data-core (slot-value expr :new-value) env aux-decl-queue df-info))
          (array-type (sal-expr/type expr))
          (domain (sal-function-type/domain array-type))
          (range (sal-function-type/range array-type))
          (range-num-atoms (sal-type/num-atom-types range))
          (it (sal-type/make-iterator domain))
          (idx (evaluate-or-false (slot-value expr :idx)))
          (result-value-queue (make-queue)))
     [assert (new-value-list range-num-atoms range) (= (length new-value-list) range-num-atoms)]
     (unless (iterator/has-next? it)
       (sign-source-error (slot-value expr :target) "Invalid array, the domain is empty."))
     (if (and idx (sal-expr/first-order-value? idx))
       (let ((found? #f))
         (iterator/for-each 
          (lambda (domain-value)
            ;; I cannot use env here, the env I have is incompatible with sal-expr/equal-values?
            ;; Remark: sal-expr/equal-values? possible results: #t, #f, 'dont-known
            (let ((equal-value? (sal-expr/equal-values? domain-value idx (make-empty-env))))
              (cond
               ((eq? equal-value? #t)
                (queue/append! result-value-queue new-value-list)
                (set! found? #t))
               ((eq? equal-value? #f)
                (let ((curr-value-list (list-head array-value-list range-num-atoms)))
                  (queue/append! result-value-queue curr-value-list)))
               (else
                (sign-unsupported-feature expr "Failed to flatten data structures in function update (array update). The equality test failed. Please contact support."))))
            (set! array-value-list (list-tail array-value-list range-num-atoms)))
          it)
         (unless found?
           (sign-source-error expr "The index is not in the domain of the array.")))
       (let ((idx-value-list (sal-expr/flat-data-core (slot-value expr :idx) env aux-decl-queue df-info)))
         (iterator/for-each 
          (lambda (domain-value)
            (let* ((domain-value-list (sal-expr/flat-data-core domain-value env aux-decl-queue df-info))
                   (place-provider expr)
                   (condition (make-bool-expr-alias! (make-sal-and+* (map (lambda (idx-value dom-val)
                                                                            (make-sal-equality+ idx-value dom-val))
                                                                          idx-value-list
                                                                          domain-value-list)
                                                                     place-provider)
                                                     aux-decl-queue
                                                     'cond))
                   (curr-value-list (list-head array-value-list range-num-atoms))
                   (new-value-list (map (lambda (curr-value new-value)
                                          (make-sal-cond+ condition new-value curr-value place-provider))
                                        curr-value-list
                                        new-value-list)))
              (queue/append! result-value-queue new-value-list)
              (set! array-value-list (list-tail array-value-list range-num-atoms))))
          it)))
     (queue->list result-value-queue))
   (catch 'type-iterator
          (lambda (msg)
            (sign-unsupported-feature expr "Failed to flatten data structures in the array update, reason: ~a" msg)))))


(define-method (sal-expr/flat-data-core (expr <sal-array-update>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let* ((array (slot-value expr :target))
         (array-type (sal-expr/type array))
         (domain (sal-function-type/domain array-type)))
    (if (and *sal-flat-finite-domain-functions*
             (sal-type/finite? domain))
      (sal-array-update/flat-data-with-finite-domain expr env aux-decl-queue df-info)
      (sal-array-update/flat-data-core expr env aux-decl-queue df-info))))

(define-method (sal-expr/flat-data-core (expr <sal-quantified-expr>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
  (let ((local-decls (slot-value expr :local-decls)))
    (multiple-value-bind
        (new-local-decls new-local-decls-groups)
        (sal-var-decls->sal-flattened-var-decls local-decls env df-info)
      (let* ((env (update-env* env local-decls new-local-decls-groups))
             (new-nested-expr (car (sal-expr/flat-data-core (slot-value expr :expr) env aux-decl-queue df-info)))
             (removed-let-decls (remove-dependent-aux-let-decls! aux-decl-queue new-local-decls))
             (new-expr (make-sal-let-expr removed-let-decls new-nested-expr))
             (result-expr (copy-ast expr
                                    :local-decls new-local-decls
                                    :expr new-expr)))
        (list result-expr)))))

; (define-method (sal-expr/flat-data-core (expr <sal-real-pred>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
;   (make-sal-true expr))

; (define-method (sal-expr/flat-data-core (expr <sal-int-pred>) (env <primitive>) (aux-decl-queue <primitive>) (df-info <sal-df-info>))
;   (make-sal-true expr))

(define (sal-expr/flat-data expr env df-info)
  (let* ((aux-decl-queue (make-queue))
         (new-expr (car (sal-expr/flat-data-core expr env aux-decl-queue df-info))))
    (make-sal-let-expr (queue->list aux-decl-queue) new-expr)))

;;--------------------------------------------------------------------
;;
;; Flatten data structures in a flat module
;;
;;--------------------------------------------------------------------
   
(define (convert-state-variables source-module target-module df-info)
  (let ((state-vars (sal-module/state-variables source-module))
        (target-var-info (slot-value target-module :var-trace-info)))
    (multiple-value-bind
        (flat-var-decls flat-var-decls-groups)
        (sal-var-decls->sal-flattened-var-decls state-vars (make-empty-env) df-info)
      [assert (state-vars flat-var-decls-groups) (= (length state-vars) (length flat-var-decls-groups))]
      (sal-module/set-state-variables! target-module flat-var-decls)
      ;; store traceability information
      (for-each (lambda (state-var-decl flat-var-decls-group)
                  (eq-hash-table/put! target-var-info
                                      state-var-decl
                                      flat-var-decls-group))
                state-vars
                flat-var-decls-groups)
      (let ((env (update-env* (make-empty-env) state-vars flat-var-decls-groups)))
        env))))

(define (convert-component-info component-info env df-info)
  (let* ((tmp-queue (make-queue))
         (proc (lambda (datum)
                 (let* ((datum (sal-ast/simplify datum))
                        (new-data-list (sal-expr/flat-data-core datum env tmp-queue df-info)))
                   [assert (tmp-queue) (queue/empty? tmp-queue)]
                   new-data-list))))
    (sal-component-info/convert-data component-info proc)))

(define (sal-flat-module/flat-data flat-module)
  (status-message :generating-flat-data-module)
  (verbose-message 1 "flattening data structure in flat module...")
  (display-runtime 2 "  flattening time: ~a secs"
    (lambda ()
      (let* ((result-module (make-ast-instance <sal-simple-data-flat-module> flat-module
                                               :original-module flat-module
                                               :var-trace-info (make-eq-hash-table)
                                               :valid-input-expr (make-sal-true flat-module)
                                               :valid-state-expr (make-sal-true flat-module)
                                               :valid-constant-expr (make-sal-true flat-module)
                                               ))
             (df-info (make-sal-df-info))
             (env (convert-state-variables flat-module result-module df-info))
             (component-info (slot-value flat-module :component-info)))
        (when (sal-component-info/contains-multi-component? component-info)
          (sign-source-error flat-module 
                             "Failed to convert flat data structures in the module. Please expand the multiasynchronous/multisynchronous composition modules."))
        (with-output-to-trace 'flat-data
                              (print "trace-info:")
                              (sal/pp (slot-value result-module :var-trace-info))
                              (print "\n------------------------"))
        (set-slot-value! result-module :transition (sal-expr/flat-data (slot-value flat-module :transition) env df-info))
        (set-slot-value! result-module :initialization (sal-expr/flat-data (slot-value flat-module :initialization) env df-info))
        (set-slot-value! result-module :definition (sal-expr/flat-data (slot-value flat-module :definition) env df-info))
        (set-slot-value! result-module :skip (sal-expr/flat-data (slot-value flat-module :skip) env df-info))
        (set-slot-value! result-module :component-info (convert-component-info component-info env df-info))
        (set-slot-value! result-module :const-trace-info (slot-value df-info :new-decl-table))
        (values result-module df-info)))
    :flat-data-module-time))


;;--------------------------------------------------------------------
;;
;; Flatten data structures in an esm module
;;
;;--------------------------------------------------------------------

(define (sal-lhs/flat-data lhs env df-info)
  (let* ((aux-decl-queue (make-queue))
         (new-lhs-list (sal-expr/flat-data-core lhs env aux-decl-queue df-info)))
    (unless (queue/empty? aux-decl-queue)
      (sign-unsupported-feature lhs "This assignment left-hand-side is not supported by this tool."))
    new-lhs-list))

(define-generic (sal-esm/flat-data-core esm env df-info))

(define-method (sal-esm/flat-data-core (ast <primitive>) (env <primitive>) (df-info <sal-df-info>))
  ast)

(define-method (sal-esm/flat-data-core (ast <sal-ast>) (env <primitive>) (df-info <sal-df-info>))
  (sign-unsupported-feature ast "Failed to flat data structures."))

(define (trivial-assignment? esm)
  (and (instance-of? esm <sal-esm-assignment>)
       (let ((lhs (slot-value esm :lhs))
             (rhs (slot-value esm :rhs)))
         (and (instance-of? rhs <sal-name-expr>)
              (instance-of? lhs <sal-next-operator>)
              (instance-of? (slot-value lhs :name-expr) <sal-name-expr>)
              (sal-ast/equivalent? rhs (slot-value lhs :name-expr))))))

(define (make-esm-seq statements place-provider)
  (let ((new-statements (filter (lambda (stmt) (not (trivial-assignment? stmt))) statements)))
    (make-ast-instance <sal-esm-seq> place-provider
                       :statements new-statements)))

(define-method (sal-esm/flat-data-core (esm <sal-esm-assignment>) (env <primitive>) (df-info <sal-df-info>))
  (let ((lhs (slot-value esm :lhs))
        (rhs (slot-value esm :rhs)))
    (cond 
     ((sal-lhs/ground? lhs)
      (let* ((lhs-list (sal-lhs/flat-data lhs env df-info))
             (aux-decl-queue (make-queue))
             (rhs-list (sal-expr/flat-data-core rhs env aux-decl-queue df-info))
             (new-decls (queue->list aux-decl-queue)))
        (make-esm-seq (map (lambda (lhs-atom rhs-atom)
                             (let* ((num-ref-proc (sal-ast/number-of-references-proc rhs-atom new-decls))
                                    (used-decls (filter (lambda (decl)
                                                          (> (num-ref-proc decl) 0))
                                                        new-decls)))
                               (copy-ast esm 
                                         :lhs lhs-atom
                                         :rhs (make-sal-let-expr used-decls rhs-atom))))
                           lhs-list
                           rhs-list)
                      esm)))
     (else
      (sign-unsupported-feature esm "This tools does not support this kind of assignment.")))))

(define-method (sal-esm/flat-data-core (esm <sal-esm-guard>) (env <primitive>) (df-info <sal-df-info>))
  (copy-ast esm :expr (sal-expr/flat-data (slot-value esm :expr) env df-info)))

(define-method (sal-esm/flat-data-core (esm <sal-esm-composition-statement>) (env <primitive>) (df-info <sal-df-info>))
  (copy-ast esm :statements (map (cut sal-esm/flat-data-core <> env df-info) (slot-value esm :statements))))

(define (sal-esm-module/flat-data esm)
  (status-message :generating-flat-data-module)
  (verbose-message 1 "flattening data structure in esm...")
  (display-runtime 2 "  flattening time: ~a secs"
    (lambda ()
      (let* ((result-module (make-ast-instance <sal-data-flat-esm-module> esm
                                               :original-module esm
                                               :var-trace-info (make-eq-hash-table)))
             (df-info (make-sal-df-info #f))
             (env (convert-state-variables esm result-module df-info)))
        (set-slot-value! result-module :initialization (sal-esm/flat-data-core (slot-value esm :initialization) env df-info))
        (set-slot-value! result-module :transition (sal-esm/flat-data-core (slot-value esm :transition) env df-info))
        (set-slot-value! result-module :definition (sal-esm/flat-data-core (slot-value esm :definition) env df-info))
        (values result-module df-info)))
    :flat-data-module-time))

;;--------------------------------------------------------------------
;;
;; Flatten data structures in SAL ASTs
;;
;;--------------------------------------------------------------------

(define-generic (sal-ast/flat-data ast))

(define-method (sal-ast/flat-data (ast <sal-ast>))
  (sign-unsupported-feature ast "Unsupported abstract syntax tree in the data-structure flattener."))

(define-method (sal-ast/flat-data (ast <sal-expr>))
  (sal-expr/flat-data ast (make-empty-env) (make-sal-df-info)))

(define-method (sal-ast/flat-data (ast <sal-flat-module>))
  (sal-flat-module/flat-data ast))

(define-method (sal-ast/flat-data (assertion <sal-assertion-expr>))
  (sal-assertion/flat-data assertion (make-empty-env)))

(define-method (sal-ast/flat-data (esm <sal-esm-module>))
  (sal-esm-module/flat-data esm))

;;--------------------------------------------------------------------
;;
;; Flatten data structures in assertions
;;
;;--------------------------------------------------------------------

(define-generic (sal-assertion/flat-data ast env))

(define-method (sal-assertion/flat-data (ast <sal-ast>) (env <primitive>))
  (sal-ast/map ast env sal-assertion/flat-data))

(define (sal-state-expr/flat-data expr env flat-module df-info)
  (let* ((original-module (sal-derived-flat-module/original-flat-module flat-module))
         (original-simple-data-module (sal-derived-flat-module/original-simple-data-flat-module flat-module))
         (state-vars (slot-value original-module :state-vars))
         (traceability-table (slot-value original-simple-data-module :var-trace-info))
         (new-env (fold-left (lambda (new-env state-var-decl)
                               (let ((new-decls (let ((entry (eq-hash-table/get traceability-table state-var-decl)))
                                                  [assert (expr flat-module state-var-decl entry traceability-table state-var-decl) (and entry (pair? entry))]                                                  (cdr entry))))
                                 (update-env new-env state-var-decl new-decls)))
                             env
                             state-vars)))
    (sal-expr/flat-data expr new-env df-info)))
    
(define-method (sal-assertion/flat-data (ast <sal-module-models>) (env <primitive>))
  (let ((module (slot-value ast :module)))
    (unless (instance-of? module <sal-flat-module>)
      (sign-error "You have to flat the modules in an assertion before flattening the data structures."))
    (multiple-value-bind
        (new-module df-info)
        (sal-flat-module/flat-data module)
      (let ((new-property (begin
                            (status-message :generating-flat-data-property)
                            (verbose-message 1 "flattening data structures in the property...")
                            (display-runtime 2 "  flattening time: ~a secs"
                              (lambda ()
                                (sal-ast/expand-names (sal-state-expr/flat-data (slot-value ast :expr) env new-module df-info)
                                                      (make-empty-env)))
                              :flat-data-property-time))))
        (update-ast-slots ast
                          :module new-module
                          :expr new-property)))))

;;--------------------------------------------------------------------
;; populate a mapping from 
;; data-decl ==> expression
;; 
;; For instance, if the variable x::(tuple bool nat) was broken
;; in x!1::bool x!2::nat, the mapping will contain:
;;      x!1::bool ==> x.1
;;      x!2::bool ==> x.2
;;
;; This mapping is mainly used to produce counterexamples.
;;
;; This function can be seen as the inverse of sal-type->flattened-var-decls.
;; Parameters:
;; - type: type of the original decl
;; - decl-list: list of flattened declarations
;; - expr: 
;; - inv-map: eq-hash-table (decl -> expr)
;;
;;--------------------------------------------------------------------
(define (populate-inv-flat-data-map! type decl-list expr inv-map)
  [sal-assert "populate-inv-flat-data-map!"
              (type decl-list) (= (sal-type/num-atom-types type)
                                  (length decl-list))]
  (populate-inv-flat-data-map-core! type decl-list expr
                                    (lambda (decl-list expr)
                                      [assert (decl-list) (= (length decl-list) 1)]
                                      (eq-hash-table/put! inv-map (car decl-list) expr))))
(define-generic (populate-inv-flat-data-map-core! type decl-list expr put-proc!))
(define-method (populate-inv-flat-data-map-core! (type <sal-type>) (decl-list <primitive>) (expr <sal-expr>) (put-proc! <primitive>))
  (put-proc! decl-list expr))
(define-method (populate-inv-flat-data-map-core! (type <sal-state-type>) (decl-list <primitive>) (expr <sal-expr>) (put-proc! <primitive>))
  (populate-inv-flat-data-map-core! (sal-module/type (slot-value type :module)) decl-list expr put-proc!))
(define-method (populate-inv-flat-data-map-core! (type <sal-type-name>) (decl-list <primitive>) (expr <sal-expr>) (put-proc! <primitive>))
  (let ((definition (sal-type-name/definition type)))
    (if definition
      (cond
       ((or (sal-type/number? definition)
            (instance-of? definition <sal-scalar-type>))
        (put-proc! decl-list expr))
       (else
        (populate-inv-flat-data-map-core! definition decl-list expr put-proc!)))
      (put-proc! decl-list expr))))
(define-method (populate-inv-flat-data-map-core! (type <sal-subtype>) (decl-list <primitive>) (expr <sal-expr>) (put-proc! <primitive>))
  (cond
   ((sal-type/number? type)
    (put-proc! decl-list expr))
   ((sal-type/flattenable? type)
    (populate-inv-flat-data-map-core! (sal-subtype/immediate-super-type type) decl-list expr put-proc!))
   (else
    (put-proc! decl-list expr))))
(define-method (populate-inv-flat-data-map-core! (type <sal-tuple-type>) (decl-list <primitive>) (expr <sal-expr>) (put-proc! <primitive>))
  (let ((place-provider expr))
    (let loop ((types (slot-value type :types))
               (decl-list decl-list)
               (idx 1))
      (unless (null? types)
        (let* ((curr-type (car types))
               (curr-num-atoms (sal-type/num-atom-types curr-type))
               (curr-decl-list (list-head decl-list curr-num-atoms))
               (curr-expr (make-ast-instance <sal-tuple-selection> place-provider
                                             :target expr
                                             :idx (make-sal-numeral idx place-provider))))
          (populate-inv-flat-data-map-core! curr-type curr-decl-list curr-expr put-proc!)
          (loop (cdr types)
                (list-tail decl-list curr-num-atoms)
                (+ idx 1)))))))
(define-method (populate-inv-flat-data-map-core! (type <sal-record-type>) (decl-list <primitive>) (expr <sal-expr>) (put-proc! <primitive>))
  (let ((place-provider expr))
    (let loop ((fields (slot-value type :fields))
               (decl-list decl-list))
      (unless (null? fields)
        (let* ((curr-field (car fields))
               (curr-type (slot-value curr-field :type))
               (curr-num-atoms (sal-type/num-atom-types curr-type))
               (curr-decl-list (list-head decl-list curr-num-atoms))
               (curr-expr (make-ast-instance <sal-record-selection> place-provider
                                             :target expr
                                             :idx (slot-value curr-field :id))))
          (populate-inv-flat-data-map-core! curr-type curr-decl-list curr-expr put-proc!)
          (loop (cdr fields)
                (list-tail decl-list curr-num-atoms)))))))
(define-method (populate-inv-flat-data-map-core! (type <sal-function-type>) (decl-list <primitive>) (expr <sal-expr>) (put-proc! <primitive>))
  (if (and *sal-flat-finite-domain-functions* 
           (sal-type/finite? (slot-value type :domain)))
    (try
     (let* ((range (slot-value type :range))
            (range-num-atoms (sal-type/num-atom-types range))
            (domain (slot-value type :domain))
            (it (sal-type/make-iterator domain))
            (domain-values (iterator->list it)))
       (let loop ((domain-values domain-values)
                  (decl-list decl-list))
         (unless (null? domain-values)
           (let ((curr-expr (sal-expr/apply expr (car domain-values)))
                 (curr-decl-list (list-head decl-list range-num-atoms)))
             (populate-inv-flat-data-map-core! range curr-decl-list curr-expr put-proc!))
           (loop (cdr domain-values)
                 (list-tail decl-list range-num-atoms)))))
     (catch 'type-iterator
            (lambda (msg)
              (sign-unsupported-feature type "Failed to recover information, reason: ~a" msg))))
    ;; If only the range was flattened... I use the following trick
    ;; Assume that: f::(-> nat (tuple bool bool)) ==> f!1 f!2
    ;; Then
    ;;   f!1 ==> (LAMBDA (x::nat) (f x).1)
    ;;   f!2 ==> (LAMBDA (x::nat) (f x).2)
    (let ((range (slot-value type :range)))
      (if (= (sal-type/num-atom-types range) 1)
        (put-proc! decl-list expr)
        (let* ((arg-types (sal-function-type/domain-types type))
               (arg-decls (sal-type-list->sal-decl-list arg-types))
               (arg-name-exprs (sal-decl-list->sal-name-expr-list arg-decls))
               (new-expr (sal-expr/apply expr (apply make-application-argument arg-name-exprs)))
               (new-put-proc! (lambda (decl-list to-expr)
                                (put-proc! decl-list
                                           (make-ast-instance <sal-lambda> expr
                                                              :local-decls arg-decls
                                                              :expr to-expr)))))
          (populate-inv-flat-data-map-core! range decl-list new-expr new-put-proc!))))))
                                                  
;;--------------------------------------------------------------------
;;
;; Flat data ==> sal value
;;
;; This function is similar to bit-list->sal-values
;;
;;--------------------------------------------------------------------
(define-generic (data-list->sal-value type data-list))

(define-method (data-list->sal-value (type <sal-type>) (data-list <primitive>))
  [assert (data-list type) (= (length data-list) 1)]
  (car data-list))
(define-method (data-list->sal-value (type <sal-state-type>) (data-list <primitive>))
  (data-list->sal-value (sal-module/type (slot-value type :module)) data-list))
(define-method (data-list->sal-value (type <sal-type-name>) (data-list <primitive>))
  (let ((definition (sal-type-name/definition type)))
    (if definition
      (cond
       ((or (sal-type/number? definition)
            (instance-of? definition <sal-scalar-type>))
        (call-next-method))
       (else
        (data-list->sal-value definition data-list)))
      (call-next-method))))
(define-method (data-list->sal-value (type <sal-subtype>) (data-list <primitive>))
  (cond
   ((sal-type/number? type)
    (call-next-method))
   ((sal-type/flattenable? type)
    (data-list->sal-value (sal-subtype/immediate-super-type type) data-list))
   (else
    (call-next-method))))
(define-method (data-list->sal-value (type <sal-domain-tuple-type>) (data-list <primitive>))
  (change-ast-class (call-next-method)
                    <sal-arg-tuple-literal>))
(define-method (data-list->sal-value (type <sal-tuple-type>) (data-list <primitive>))
  (let ((place-provider type)
        (expr-queue (make-queue)))
    (let loop ((types (slot-value type :types))
               (data-list data-list))
      (if (null? types)
        (make-ast-instance <sal-tuple-literal> type
                           :exprs (queue->list expr-queue))
        (let* ((curr-type (car types))
               (curr-num-atoms (sal-type/num-atom-types curr-type))
               (curr-data-list (list-head data-list curr-num-atoms))
               (curr-expr (data-list->sal-value curr-type curr-data-list)))
          (queue/insert! expr-queue curr-expr)
          (loop (cdr types)
                (list-tail data-list curr-num-atoms)))))))
(define-method (data-list->sal-value (type <sal-record-type>) (data-list <primitive>))
  (let ((place-provider type)
        (entry-queue (make-queue)))
    (let loop ((fields (slot-value type :fields))
               (data-list data-list))
      (if (null? fields)
        (make-ast-instance <sal-record-literal> type
                           :entries (queue->list entry-queue))
        (let* ((curr-field (car fields))
               (curr-type (slot-value curr-field :type))
               (curr-num-atoms (sal-type/num-atom-types curr-type))
               (curr-data-list (list-head data-list curr-num-atoms))
               (curr-expr (data-list->sal-value curr-type curr-data-list))
               (curr-entry (make-ast-instance <sal-record-entry> curr-field
                                              :id (slot-value curr-field :id)
                                              :expr curr-expr)))
          (queue/insert! entry-queue curr-entry)
          (loop (cdr fields)
                (list-tail data-list curr-num-atoms)))))))
(define-method (data-list->sal-value (type <sal-array-type>) (data-list <primitive>))
  (let ((result (call-next-method)))
    (if (instance-of? result <sal-lambda>)
      (change-ast-class result <sal-array-literal>)
      result)))
(define-method (data-list->sal-value (type <sal-function-type>) (data-list <primitive>))
  (let ((domain (slot-value type :domain))
        (range (slot-value type :range)))
    (if (and *sal-flat-finite-domain-functions* 
           (sal-type/finite? domain))
      (try
       (let ((it (sal-type/make-iterator domain))
             (range-num-atoms (sal-type/num-atom-types range))
             (alternatives-queue (make-queue)))
         (iterator/for-each (lambda (domain-value)
                              (let* ((curr-data-list (list-head data-list range-num-atoms))
                                     (rest-data-list (list-tail data-list range-num-atoms))
                                     (range-value (data-list->sal-value range curr-data-list)))
                                (set! data-list rest-data-list)
                                (queue/insert! alternatives-queue (cons domain-value range-value))))
                            it)
         (alt-pair-list->lambda (queue->list alternatives-queue) type))
       (catch 'type-iterator
              (lambda (msg)
                (sign-unsupported-feature type "Failed to recover information, reason: ~a" msg))))
      ;; only the range was flattened
      (let ((range (slot-value type :range)))
        (cond
         ((= (sal-type/num-atom-types range) 1)
          [assert (data-list) (= (length data-list) 1)]
          (car data-list))
         (else
          (let* ((arg-types (sal-function-type/domain-types type))
                 (arg-decls (sal-type-list->sal-decl-list arg-types))
                 (arg-name-exprs (sal-decl-list->sal-name-expr-list arg-decls))
                 (arg (apply make-application-argument arg-name-exprs))
                 (new-data-list (map (lambda (data)
                                       (sal-expr/apply data arg))
                                     data-list))
                 (new-expr (data-list->sal-value range new-data-list)))
            ;; (print "data-list->sal-value <sal-function-type> " (map sal-ast->list new-data-list) ", " (sal-ast->list new-expr))
            (make-ast-instance <sal-lambda> type
                               :local-decls arg-decls
                               :expr new-expr))))))))

;;--------------------------------------------------------------------
;;
;; flat-data-ast->ast
;;
;; Convert an AST which contains flat data in an AST without flat data.
;; This function is mainly used to generate counterexamples...
;; Remark: inv-map is the mapping constructed using the function
;;   populate-inv-flat-data-map-core!
;;--------------------------------------------------------------------
(define-generic (flat-data-ast->ast ast env inv-map))

(define-method (flat-data-ast->ast (ast <sal-ast>) (env <primitive>) (inv-map <primitive>))
  (sal-ast/map ast env (lambda (child-ast new-env) (flat-data-ast->ast child-ast new-env inv-map))))
(define-method (flat-data-ast->ast (ast <sal-name-expr>) (env <primitive>) (inv-map <primitive>))
  (cond
   ((eq-hash-table/get inv-map (slot-value ast :decl)) =>
    cdr)
   (else
    (sal-name-ref/map ast env))))

(define-method (flat-data-ast->ast (ast <sal-arith-op>) (env <primitive>) (inv-map <primitive>))
  (let* ((arg-list (map (cut flat-data-ast->ast <> env inv-map) (sal-application/argument-list ast)))
         (new-arg (apply make-application-argument arg-list)))
    (copy-ast ast
              :arg new-arg)))

(define-method (flat-data-ast->ast (ast <sal-application>) (env <primitive>) (inv-map <primitive>))
  (let* ((new-fun (flat-data-ast->ast (slot-value ast :fun) env inv-map))
         (arg-list (map (cut flat-data-ast->ast <> env inv-map) (sal-application/argument-list ast)))
         (fun-type (sal-expr/type new-fun))
         (domain (sal-function-type/domain fun-type))
         (new-arg (data-list->sal-value domain arg-list)))
;     (print "flat-data-ast->ast")
;     (sal/pp (slot-value ast :arg))
;     (print "")
;     (sal/pp new-arg)
;     (print "\n------------------")
    (sal-expr/apply-conservative new-fun new-arg)))





