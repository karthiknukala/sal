;;
;; SAL 3.1, Copyright (C) 2006, 2011, SRI International.  All Rights Reserved.
;;
;; SAL is free software; you can redistribute it and/or 
;; modify it under the terms of the GNU General Public License 
;; as published by the Free Software Foundation; either version 2
;; of the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of 
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
;; GNU General Public License for more details. 
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software 
;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
;;

(sal/reset!)
(sal-env/set-salpath! *sal-env* '("../tests"))
(sal/set-pp-simplify-qualified-names-flag! #t)
(sal/set-pp-max-width! 10000)
(sal/set-pp-max-ribbon! 10000)
(sal/set-sal-pp-proc! sal-ast->lsal-doc)

(define (check-core tst-name thunk)
  (try
   (begin
     (display* "checking \"" tst-name "\"... ")
     (flush-output-port (current-output-port))
     (unless (thunk)
       (print "failed.")
       (exit -1))
     (print "done."))
   (lambda (escape proc msg obj)
     (print "failed.")
     (notify-error proc msg obj)
     (exit -1))))
     
(define-macro (check tst-name . body)
  `(check-core ,tst-name (lambda () ,@body)))

(define (check-item-core item-name thunk)
  (try
   (unless (thunk)
     (error #unspecified #unspecified #unspecified))
   (lambda (escape proc msg obj)
     (print "failed on item `" item-name "'.")
     (notify-error proc msg obj)
     (exit -1))))

(define-macro (check-item item-name . body)
  `(check-item-core ,item-name (lambda () ,@body)))

(print "validating...")

(check "import"
       (check-item "importing mutex" (sal/context "mutex"))
       (check-item "importing arbiter" (sal/context "arbiter"))
       (check-item "importing four-slot" (sal/context "four-slot"))
       (check-item "importing pathfinder" (sal/context "pathfinder"))
       (check-item "importing math" (sal/context "math"))
       (check-item "importing pcp" (sal/context "tst-pcp-generic")))

(sal/set-trace-info-enabled! #t)

(check "flattener with trace info"
       (check-item "flattening mutex" (sal-ast/flat-modules (sal/module "(@ system mutex)")))
       (check-item "flattening four-slot" (sal-ast/flat-modules (sal/module "(@ system four-slot)")))
       (check-item "flattening arbiter" (sal-ast/flat-modules (sal/module "(@ arbiter (arbiter () (10)))")))
       (check-item "flattening pathfinder" (sal-ast/flat-modules (sal/module "(@ system pathfinder)")))
       (check-item "flattening pcp" (sal-ast/flat-modules (sal/module "(@ tst-system tst-pcp-generic)"))))

(sal/set-trace-info-enabled! #f)

(check "flattener without trace info"
       (check-item "flattening mutex" (sal-ast/flat-modules (sal/module "(@ system mutex)")))
       (check-item "flattening four-slot" (sal-ast/flat-modules (sal/module "(@ system four-slot)")))
       (check-item "flattening arbiter" (sal-ast/flat-modules (sal/module "(@ arbiter (arbiter () (10)))")))
       (check-item "flattening pathfinder" (sal-ast/flat-modules (sal/module "(@ system pathfinder)")))
       (check-item "flattening pcp" (sal-ast/flat-modules (sal/module "(@ tst-system tst-pcp-generic)"))))

(sal/set-trace-info-enabled! #t)

(define (check-simplifier expr expected-result)
  (check-item (string-append "simplify(" expr ") = " expected-result)
              (sal-ast/equivalent? (sal-ast/simplify (sal/expr expr))
                                   (sal-ast/simplify (sal/expr expected-result)))))

(define (check-simplifier-exception expr)
  (check-item (string-append "expr \"" expr "\" didn't throw an exception")
              (try
               (begin
                 (sal-ast/simplify (sal/expr expr))
                 #f)
               (lambda (escape proc msg obj)
                 (escape #t)))))
              
(sal/import "vars")
(sal/import "(list (int) ())")
(check "simplifier"
       (check-simplifier "(and x true y true z)" "(and x y z)")
       (check-simplifier "(and x false y)" "false")
       (check-simplifier "(not (and x (not (and z y))))" "(or (not x) (and z y))")
       (check-simplifier "(not (and x (not (or z y))))" "(or (not x) z y)")
       (check-simplifier "(not (for-all (x1::bool) (and (not x1) y)))" "(or (exists (x1::bool) x1) (not y))")
       (check-simplifier "(not (exists (x1::bool) (and (not x1) y)))" "(or (not y) (for-all (x1::bool) x1))")
       (check-simplifier "(not (implies x y))" "(and x (not y))")
       (check-simplifier "(not (xor x y))" "(= x y)")
       (check-simplifier "(not (iff x y))" "(/= x y)")
       (check-simplifier "(if (= true false) 10 20)" "20")
       (check-simplifier "(mk-tuple 10 20 30).1" "10")
       (check-simplifier "(mk-tuple 10 20 30).3" "30")
       (check-simplifier "(update (mk-tuple 10 20 30) .1 100)" "(mk-tuple 100 20 30)")
       (check-simplifier "(update (mk-array (idx::nat) 0) [1] 10)[1]" "10")
       (check-simplifier "(update (update (mk-array (idx::nat) 0) [1] 10) [2] 20)[1]" "10")
       (check-simplifier "(update (update (update (mk-array (idx::nat) 0) [1] 10) [2] 20) [3] 30)[1]" "10")
       (check-simplifier "(update (update (update (mk-array (idx::nat) 0) [1] 10) [2] 20) [3] 30)[10]" "0")
       (check-simplifier "(update (update (update (mk-array (idx::nat) 0) [1] 10) [2] 20) [3] 30)[2]" "20")
       (check-simplifier "(update (update (update arr [1] 10) [2] 20) [3] 30)[10]" "arr[10]")
       (check-simplifier "(update (update (update arr [1] 10) [2] 20) [3] 30)[10]" "arr[10]")
       (check-simplifier "(update (update (update arr [1] 10) [i] 20) [3] 30)[10]" "(update (update arr [1] 10) [i] 20)[10]")
       (check-simplifier "(mk-record idx::10 flag::true aux::20).idx" "10")
       (check-simplifier "(mk-record idx::10 flag::true aux::20).flag" "true")
       (check-simplifier "(mk-record idx::10 flag::true aux::20).aux" "20")        
       (check-simplifier "(update (mk-record idx::10 flag::true aux::20) .idx 20)" "(mk-record idx::20 flag::true aux::20)")
       (check-simplifier "(update (mk-record idx::10 flag::true aux::20) .flag false)" "(mk-record idx::10 flag::false aux::20)")
       (check-simplifier "(let ((x::nat 10)) 1)" "1")
       (check-simplifier "(let ((x::nat 1) (y::nat 2)) (+ y 1))" "3")
       (check-simplifier "(let ((b1::bool (and x y)) (b2::bool true)) (and b1 b1 b2))" "(let ((b1::bool (and x y))) (and b1 b1))")
       (check-simplifier "(if x 10 10)" "10")
       (check-simplifier "(if true x y)" "x")
       (check-simplifier "(if false x y)" "y")
       (check-simplifier "(if x y y)" "y")
       (check-simplifier "(if x true y)" "(or x y)")
       (check-simplifier "(if x false y)" "(and (not x) y)")
       (check-simplifier "(if x y false)" "(and x y)")
       (check-simplifier "(if x y true)" "(or (not x) y)")
       (check-simplifier "(+ i 0)" "i")
       (check-simplifier "(+ 0 i)" "i")
       (check-simplifier "(+ 10 20)" "30")
       (check-simplifier "(+ i j)" "(+ i j)")
       (check-simplifier "(* 0 i)" "0")
       (check-simplifier "(* i 0)" "0")
       (check-simplifier "(* 1 i)" "i")
       (check-simplifier "(* i 1)" "i")
       (check-simplifier "(* 10 20)" "200")
       (check-simplifier "(- 10 20)" "-10")
       (check-simplifier "(- i j)" "(- i j)")
       (check-simplifier "(mod 10 2)" "0")
       (check-simplifier "(mod 10 3)" "1")
       (check-simplifier "(mod 10 4)" "2")
       (check-simplifier "(div 10 2)" "5")
       (check-simplifier "(div 10 3)" "3")
       (check-simplifier "(div 10 4)" "2")
       (check-simplifier "(iff x x)" "true")
       (check-simplifier "(iff x true)" "x")
       (check-simplifier "(iff x false)" "(not x)")
       (check-simplifier "(iff x y)" "(iff x y)")
       (check-simplifier "(iff true false)" "false")
       (check-simplifier "(iff false true)" "false")
       (check-simplifier "(iff false false)" "true")
       (check-simplifier "(iff true true)" "true")
       (check-simplifier "(xor x x)" "false")
       (check-simplifier "(xor x true)" "(not x)")
       (check-simplifier "(xor x false)" "x")
       (check-simplifier "(xor x y)" "(xor x y)")
       (check-simplifier "(xor true false)" "true")
       (check-simplifier "(xor false true)" "true")
       (check-simplifier "(xor false false)" "false")
       (check-simplifier "(xor true true)" "false")
       (check-simplifier "a[true]" "a[true]")
       (check-simplifier "(= (mk-record idx::10 val::20) (mk-record val::20 idx::10))" "true")
       (check-simplifier "(= (mk-tuple 10 20) (mk-tuple 10 20))" "true")
       (check-simplifier "(= x x)" "true")
       (check-simplifier "(= (+ i j) (+ i j))" "true") 
       (check-simplifier "(nil? nil)" "true")
       (check-simplifier "(nil? (cons 10 nil))" "false")
       (check-simplifier "(nil? (cons 10 (cons 20 nil)))" "false")
       (check-simplifier "(cons? (cons 10 (cons 20 nil)))" "true")
       (check-simplifier "(cons? nil)" "false")
       (check-simplifier "(cons? (cons 10 nil))" "true")
       (check-simplifier "(cons? (if (= x y) nil (cons 10 nil)))" "(cons? (if (= x y) nil (cons 10 nil)))")
       (check-simplifier "(cons? (if (= x y) nil nil))" "false")
       (check-simplifier "(car (cons 20 nil))" "20")
       (check-simplifier "(cdr (cons 10 nil))" "nil")
       (check-simplifier "(cdr (cons 20 (cons 10 nil)))" "(cons 10 nil)")
       (check-simplifier "(car (if (= 1 1) (cons 10 nil) (cons 20 nil)))" "10")
       (check-simplifier "(car (cdr (cons 10 (cons 20 nil))))" "20")
       (check-simplifier "(and (/= 0 0) (= 0 (/ 3 0)))" "false")
       (check-simplifier "(for-all (x::(subrange 0 2)) (for-all (y::(subrange (+ i 1) 3)) (< x y)))"
                         "(for-all (x::(subrange 0 2)) (for-all (y::(subrange (+ i 1) 3)) (< x y)))")
       (check-simplifier "(for-all (k1::bool) (and x k1 (= y x)))" "(and x (for-all (k1::bool) k1) (= y x))")
       (check-simplifier "(for-all (k1::bool) (and x k1 (= y k1)))" "(and x (for-all (k1::bool) k1) (for-all (k1::bool) (= y k1)))")
       (check-simplifier "(for-all (k1::bool) (not (or x k1 (= y x))))" "(not (or x (exists (k1::bool) k1) (= y x)))")
       (check-simplifier "(for-all (k1::bool) (not (or x k1 (not (and (= y x) z)))))"
                         "(and (not x) (for-all (k1::bool) (not k1)) (= y x) z)")
       (check-simplifier "(exists (k1::bool) (or x k1 y))" "(or x (exists (k1::bool) k1) y)")
       (check-simplifier "(exists (k1::bool) (or x (exists (k2::bool) (or k1 (= k1 k2))) (= k1 y)))"
                         "(or x (exists (k1::bool) k1) (exists (k1::bool k2::bool) (= k1 k2)) (exists (k1::bool) (= k1 y)))")
       (check-simplifier "(exists (k1::bool) (and x y k1))"
                         "(and x y (exists (k1::bool) k1))")
       (check-simplifier "(exists (k1::bool k2::bool) (and x y k1))"
                         "(and x y (exists (k1::bool) k1))")
       (check-simplifier "(exists (k1::bool k2::bool) (and x y (= k1 k2) k1))"
                         "(and x y (exists (k1::bool) (and k1 (exists (k2::bool) (= k1 k2)))))")
       (check-simplifier "(exists (k1::bool k2::bool) (and x y z))" "(and x y z)")
       (check-simplifier "(exists (k1::bool k2::bool) (and x k2 z))"
                         "(and x z (exists (k2::bool) k2))")
       (check-simplifier "(exists (k1::bool k2::bool) (and x (= k1 k2) z))"
                         "(and x z (exists (k1::bool k2::bool) (= k1 k2)))")
       (check-simplifier "(for-all (k1::bool k2::bool) (or x (= k1 k2) z))"
                         "(or x z (for-all (k1::bool k2::bool) (= k1 k2)))")
       (check-simplifier-exception "(car nil)")
       (check-simplifier-exception "(cdr nil)")
       (check-simplifier-exception "(/ 10 0)")
       (check-simplifier-exception "(mod 10 0)")
       (check-simplifier-exception "(div 10 0)")
       )


(define (check-iterator-core type-str expected-result)
  (let ((result (with-output-to-string
                  (lambda ()
                    (sal/pp (map sal-ast/rename-variables (iterator->list (sal-type/make-iterator (sal/type type-str)))))))))
    ;; (print "result = " result)
    (equal? result expected-result)))

(define (check-iterator type-str expected-result)
  (check-item (string-append "elems(" type-str ")= " expected-result)
              (check-iterator-core type-str expected-result)))

(check "iterators"
       (check-iterator "(subrange 1 4)" "(1 2 3 4)")
       (check-iterator "bool" "(false true)")
       (check-iterator "(@ PC mutex)" "(sleeping trying critical)")
       (check-iterator "(tuple bool (subrange 1 3))" "((mk-tuple false 1) (mk-tuple true 1) (mk-tuple false 2) (mk-tuple true 2) (mk-tuple false 3) (mk-tuple true 3))")
       (check-iterator "(record idx::bool pc::(@ PC mutex))" "((mk-record idx::false pc::sleeping) (mk-record idx::true pc::sleeping) (mk-record idx::false pc::trying) (mk-record idx::true pc::trying) (mk-record idx::false pc::critical) (mk-record idx::true pc::critical))")
       (check-iterator "(array bool bool)" "((mk-array (arg::bool) (if (= arg false) false false)) (mk-array (arg::bool) (if (= arg false) true false)) (mk-array (arg::bool) (if (= arg false) false true)) (mk-array (arg::bool) (if (= arg false) true true)))")
       (check-iterator "(@ msg data)" "((msg1 0) (msg1 1) (msg1 2) (msg1 3) (msg1 4) (msg1 5) (msg1 6) (msg1 7) (msg1 8) (msg1 9) (msg1 10) (msg2 false false) (msg2 true false) (msg2 false true) (msg2 true true) empty-msg)")
       (check-iterator "(-> bool bool)" "((lambda (arg::bool) (if (= arg false) false false)) (lambda (arg::bool) (if (= arg false) true false)) (lambda (arg::bool) (if (= arg false) false true)) (lambda (arg::bool) (if (= arg false) true true)))")
       (check-iterator "(subtype (lambda (x::(subrange 1 8)) (and (/= x 3) (/= x 7))))" "(1 2 4 5 6 8)")
       (check-iterator "(tuple (subtype (lambda (x::bool) (= x true))) bool)" "((mk-tuple true false) (mk-tuple true true))")
       (check-iterator "(subtype (lambda (x::(subtype (lambda (y::nat) (< y 8)))) (> x 3)))" "(4 5 6 7)"))



(define (check-finite-type type)
  (check-item (string-append type " is not finite")
              (sal-type/finite? (sal/type type))))

(define (check-infinite-type type)
  (check-item (string-append type " is not infinite")
              (not (sal-type/finite? (sal/type type)))))

(check "finite type detection"
       (check-finite-type "bool")
       (check-finite-type "(@ PC mutex)")
       (check-finite-type "(tuple bool (@ PC mutex))")
       (check-finite-type "(subrange 10 20)")
       (check-finite-type "(record idx::bool val::(subrange 0 10))")
       (check-finite-type "(array bool bool)")
       (check-finite-type "(-> (tuple bool bool) bool)")
       (check-infinite-type "(@ list (list (nat) ()))")
       (check-infinite-type "(@ list (list (bool) ()))")
       (check-finite-type "(@ msg data)")
       (check-infinite-type "nat")
       (check-infinite-type "real")
       (check-infinite-type "int")
       (check-infinite-type "(-> int bool)")
       (check-infinite-type "(-> nat bool)")
       (check-infinite-type "(array int bool)")
       (check-infinite-type "(array bool int)")
       (check-infinite-type "(tuple bool bool nat)")
       (check-infinite-type "(record idx::nat)")
       (check-infinite-type "(subtype (lambda (x::nat) (> x 10)))")
       (check-finite-type "(subtype (below 4))")
       (check-finite-type "(subtype (up-to 10))")
       (check-finite-type "(subtype (lambda (x::nat) (and (< x 13) (> x 10))))")
       (check-finite-type "(subtype (lambda (x::(subtype (lambda (y::nat) (> y 5)))) (and (<= x 10) (/= x 3) (/= x 8) (> x 0))))")
       )

(define (check-type-union type1 type2 expected-result)
  (let* ((t1 (sal/type type1))
         (t2 (sal/type type2))
         (result (sal-type/union t1 t2)))
    (check-item (string-append "union(" type1 ", " type2 ") = " expected-result)
                (sal-ast/equivalent? result (sal/type expected-result)))))

(check "type union"
       (check-type-union "nat" "nat" "nat")
       (check-type-union "nat" "int" "int")
       (check-type-union "int" "nat" "int")
       (check-type-union "int" "int" "int")
       (check-type-union "real" "nat" "real")
       (check-type-union "number" "int" "number")
       (check-type-union "(tuple nat real)" "(tuple int int)" "(tuple int real)")
       (check-type-union "int" "(subrange 0 10)" "int"))

(define (check-type-num-elems type expected-result)
  (check-item (string-append "approx-num-elems(" type ") = " expected-result)
              (=mpq (sal-type/number-of-elements (sal/type type)) (make-mpq expected-result))))

(define (check-type-num-elems-infinite type)
  (check-item (string-append "approx-num-elems(" type ") = infinite")
              (eq? (sal-type/number-of-elements (sal/type type) sal-expr/evaluate) 'infinite)))
  

(check "type approx. number of elements"
       (check-type-num-elems "(tuple bool bool bool)" "8")
       (check-type-num-elems "(array (subrange 1 4) bool)" "16")
       (check-type-num-elems "(array (subrange 1 4) (subrange 1 3))" "81")
       (check-type-num-elems "(-> (tuple bool bool) bool)" "16")
       (check-type-num-elems "(-> (@ PC mutex) bool)" "8")
       (check-type-num-elems "(@ msg data)" "16")
       (check-type-num-elems "(record idx::bool flag::(subrange 1 7))" "14")
       (check-type-num-elems "(subrange -2 4)" "7")
       (check-type-num-elems "(subtype (up-to 3))" "4")
       (check-type-num-elems "(subtype (below 3))" "3")
       (check-type-num-elems "(subtype (lambda (idx::(subrange 3 (+ 1 6))) (/= idx 4)))" "5")
       (check-type-num-elems "(subtype (lambda (idx::nat) (and (> idx 3) (< idx 8))))" "4")
       (check-type-num-elems "(subtype (lambda (idx::nat) (and (> idx 3) (/= idx 5) (< idx 8))))" "4")
       (check-type-num-elems "(subtype (lambda (idx::nat) (and (> idx 3) (/= idx 5) (<= idx 8))))" "5")
       (check-type-num-elems-infinite "nat")
       (check-type-num-elems-infinite "(-> nat nat)")
       (check-type-num-elems-infinite "(tuple nat bool)")
       (check-type-num-elems-infinite "(@ list (list (bool) ()))"))
       

(define (check-evaluator expr expected-result)
  (check-item (string-append "evaluator(" expr ") = " expected-result)
              (sal-ast/equivalent? (sal-expr/evaluate (sal/expr expr))
                                   (sal/expr expected-result))))

(sal/import "math-tst")
(check "evaluator"
       (check-evaluator "(fact 4)" "24")
       (check-evaluator "(fact 20)" "2432902008176640000")
       (check-evaluator "(fact 10)" "3628800")
       (check-evaluator "(fib 4)" "5")
       (check-evaluator "(fib 5)" "8")
       (check-evaluator "(update (mk-array (idx::nat) 0) [1] 10)" "(mk-array (idx::nat) (if (= idx 1) 10 0))")
       (check-evaluator "(for-all (x::(subrange 1 5)) (= x 1))" "false")
       (check-evaluator "(for-all (x::(subrange 1 5)) (= x 3))" "false")
       (check-evaluator "(for-all (x::(subrange 1 5)) (< x 10))" "true")
       (check-evaluator "(for-all (x::(subrange 1 5)) (> x 3))" "false")
       (check-evaluator "(for-all (x::(subrange 1 5) y::(subrange 10 15)) (< x y))" "true")
       (check-evaluator "(for-all (x::(subrange 1 5) y::(subrange 3 15)) (< x y))" "false")
       (check-evaluator "(exists (x::(subrange 1 5)) (= x 1))" "true")
       (check-evaluator "(exists (x::(subrange 1 5)) (= x 3))" "true")
       (check-evaluator "(exists (x::(subrange 1 5)) (> x 10))" "false")
       (check-evaluator "(exists (x::(subrange 1 5)) (> x 4))" "true")
       (check-evaluator "(exists (x::(subrange 1 5) y::(subrange 1 5)) (< x y))" "true")
       (check-evaluator "(for-all (x::(subtype (below 8))) (< x 10))" "true")
       (check-evaluator "(for-all (x::(subtype (below 8))) (< x 7))" "false")
       (check-evaluator "(for-all (x::(subtype (below 8))) (< x 8))" "true")
       (check-evaluator "(for-all (x::(subtype (up-to 8))) (< x 8))" "false")
       (check-evaluator "(for-all (x::(subtype (up-to 8))) (<= x 8))" "true")
       (check-evaluator "(for-all (x::(subtype (lambda (y::nat) (and (<= y 10) (> y 3))))) (/= x 4))" "false")
       (check-evaluator "(for-all (x::(subtype (lambda (y::nat) (and (<= y 10) (/= (+ y 2) 6) (> y 3))))) (/= x 4))" "true")
       (check-evaluator "(let ((x::nat 10)) (+ x 1))" "11")
       (check-evaluator "((let ((x::nat 10)) (lambda (y::nat) (+ x y))) 20)" "30")
       )

(define (check-num-bits type expected-result)
  (check-item (string-append "finite-rep-num-bits(" type ") = " expected-result)
              (= (sal-type/finite-rep-num-bits (sal/type type)) (string->integer expected-result))))

(define (check-num-elems type expected-result)
  (check-item (string-append "finite-rep-num-elems(" type ") = " expected-result)
              (=mpq (sal-type/finite-rep-num-elems (sal/type type)) (make-mpq expected-result))))

(check "finite representation"
       (check-num-bits "bool" "1")
       (check-num-bits "(tuple bool bool)" "2")
       (check-num-bits "(record idx::(subrange 0 2) flag::bool val::(subrange 1 10))" "7")
       (check-num-bits "(@ msg data)" "6")
       (check-num-bits "(-> (tuple bool bool) bool)" "4")
       (check-num-bits "(-> (tuple (subrange 1 5) bool) (subrange 0 3))" "20")
       (check-num-bits "(@ PC mutex)" "2")
       (check-num-bits "(subtype (lambda (x::nat) (and (> x 3) (< x 22))))" "5")
       (check-num-elems "bool" "2")
       (check-num-elems "(tuple bool bool)" "4")
       (check-num-elems "(record idx::(subrange 0 2) flag::bool val::(subrange 1 10))" "60")
       (check-num-elems "(@ msg data)" "16"))

(define (check-cse expr expected-result)
  (check-item (string-append "cse(" expr ") = " expected-result)
              (let* ((result (sal-ast/cse (sal/expr expr)))
                     (expected-result (sal-ast/simplify (sal/expr expected-result))))
                (sal-ast/equivalent? result expected-result))))

(check "common subexpression elimination"
       (check-cse "10" "10")
       (check-cse "i" "i")
       (check-cse "(+ i j)" "(+ i j)")
       (check-cse "(+ (+ i j) (+ i j))" "(let ((a::int (+ i j))) (+ a a))")
       (check-cse "(let ((x::int (+ i j))) (+ (+ x x) (+ x x)))" "(let ((x::int (+ i j))) (let ((aux::int (+ x x))) (+ aux aux)))")
       (check-cse "(let ((y::int (+ i j))) (let ((x::int (+ y 1)) (z::int (+ y 1))) (+ (+ x z) (+ x z))))"
                  "(let ((cs!6::int (+ i j 1))) (let ((cs!8::int (+ cs!6 cs!6))) (+ cs!8 cs!8)))")
       )

(define (check-bec expr expected-result)
  (check-item (string-append "bec(" expr ") = " expected-result)
              (let* ((result (with-output-to-string
                               (lambda ()
                                 (sal/pp (map sal-ast/simplify (sal-expr->boolean-expr-core (sal/expr expr) (make-empty-env) (make-queue)))))))
                     (flag (equal? result expected-result)))
                (unless flag
                  (print "result produced: " result))
                flag)))

(check "boolean expression conversion"
       (check-bec "(mk-tuple true 2 4 false)" "(true false true false false true false)")
       (check-bec "(mk-record idx::3 flag::false).flag" "(false)")
       (check-bec "(mk-record idx::3 flag::false).idx" "(true true)")
       (check-bec "(mk-tuple true 4 false).2" "(false false true)")
       (check-bec "(mk-tuple true 4 false).1" "(true)")
       (check-bec "(mk-tuple true 4 false).3" "(false)")
       (check-bec "-3" "(true false true)")
       (check-bec "-1" "(true)")
       (check-bec "0" "()")
       (check-bec "3" "(true true)")
       (check-bec "21" "(true false true false true)")
       (check-bec "-21" "(true true false true false true)")
       (check-bec "(+ 3 2)" "(true false true)")
       (check-bec "(- 3 3)" "(false false false)")
       (check-bec "(- 3 2)" "(true false false)")
       (check-bec "(- 3 4)" "(true true true)")
       (check-bec "(- 21 21)" "(false false false false false false)")
       (check-bec "(- 0 0)" "()")
       (check-bec "(- 0 1)" "(true)")
       (check-bec "(- 0 2)" "(false true)")
       (check-bec "(- 0 3)" "(true false true)")
       (check-bec "(- 0 4)" "(false false true)")
       (check-bec "(- 1 0)" "(true)")
       (check-bec "(- 2 0)" "(false true)")
       (check-bec "(- 3 0)" "(true true)")
       (check-bec "(+ 0 0)" "()")
       (check-bec "(* 2 0)" "()")
       (check-bec "(* 2 1)" "(false true)")
       (check-bec "(* 2 3)" "(false true true false)")
       (check-bec "(* 4 3)" "(false false true true)")
       (check-bec "(* 3 -4)" "(false false true false true)")
       (check-bec "(* -3 4)" "(false false true false true)")
       (check-bec "(* -3 -4)" "(false false true true false)")
       (check-bec "(* 3 -2)" "(false true false true)")
       (check-bec "(* -3 -2)" "(false true true false)")
       (check-bec "(* 2 -1)" "(false true true)")
       (check-bec "(* -2 1)" "(false true true)")
       (check-bec "(div 10 4)" "(false true false false)")
       (check-bec "(div 10 3)" "(true true false false)")
       (check-bec "(div 10 1)" "(false true false true)")
       (check-bec "(div 10 2)" "(true false true false)")
       (check-bec "(div 10 10)" "(true false false false)")
       (check-bec "(div 0 10)" "(false false false false)")
       (check-bec "(div 0 1)" "(false)")
       (check-bec "(div 2 0)" "(true true)")
       (check-bec "(div 10 0)" "(true true true true)")
       (check-bec "(div -10 2)" "(true true false true true)")
       (check-bec "(div -10 3)" "(true false true true true)")
       (check-bec "(div -10 4)" "(false true true true true)")
       (check-bec "(div -5 4)" "(true true true true)")
       (check-bec "(div -5 2)" "(false true true true)")
       (check-bec "(div 0 -2)" "(false false false)")
       (check-bec "(div 0 -4)" "(false false false false)")
       (check-bec "(div -10 -2)" "(true false true false false)")
       (check-bec "(div -10 -3)" "(true true false false false)")
       (check-bec "(div -10 -4)" "(false true false false false)")
       (check-bec "(div -10 -10)" "(true false false false false)")
       (check-bec "(div 10 -2)" "(true true false true true)")
       (check-bec "(div 10 -3)" "(true false true true true)")
       (check-bec "(div 10 -4)" "(false true true true true)")
       (check-bec "(div 5 -4)" "(true true true true)")
       (check-bec "(div 5 -2)" "(false true true true)")

       (check-bec "(mod 10 4)" "(false true false false)")
       (check-bec "(mod 10 3)" "(true false false false)")
       (check-bec "(mod 10 1)" "(false false false false)")
       (check-bec "(mod 10 2)" "(false false false false)")
       (check-bec "(mod 10 10)" "(false false false false)")
       (check-bec "(mod 10 7)" "(true true false false)")
       (check-bec "(mod 7 5)" "(false true false)")
       (check-bec "(mod 0 10)" "(false false false false)")
       (check-bec "(mod 0 1)" "(false)")
       (check-bec "(mod -10 2)" "(false false false false false)")
       (check-bec "(mod -10 3)" "(true true true true true)")
       (check-bec "(mod -10 4)" "(false true true true true)")
       (check-bec "(mod -5 4)" "(true true true true)")
       (check-bec "(mod -5 2)" "(true true true true)")
       (check-bec "(mod 0 -2)" "(false false false)")
       (check-bec "(mod 0 -4)" "(false false false false)")
       (check-bec "(mod -10 -2)" "(false false false false false)")
       (check-bec "(mod -10 -3)" "(true true true true true)")
       (check-bec "(mod -10 -4)" "(false true true true true)")
       (check-bec "(mod -10 -10)" "(false false false false false)")
       (check-bec "(mod 10 -2)" "(false false false false false)")
       (check-bec "(mod 10 -3)" "(true false false false false)")
       (check-bec "(mod 10 -4)" "(false true false false false)")
       (check-bec "(mod 5 -4)" "(true false false false)")
       (check-bec "(mod 5 -2)" "(true false false false)")

       
       (check-bec "(< 3 2)" "(false)")
       (check-bec "(< 3 3)" "(false)")
       (check-bec "(< 3 4)" "(true)")
       (check-bec "(< -3 2)" "(true)")
       (check-bec "(< -3 -2)" "(true)")
       (check-bec "(< -3 -3)" "(false)")
       (check-bec "(< 0 0)" "(false)")
       (check-bec "(< -1 1)" "(true)")
       (check-bec "(< 1 -1)" "(false)")
       (check-bec "(< 1 0)" "(false)")
       (check-bec "(< 0 1)" "(true)")
       (check-bec "(<= 3 2)" "(false)")
       (check-bec "(<= 3 3)" "(true)")
       (check-bec "(<= 3 4)" "(true)")
       (check-bec "(<= -3 2)" "(true)")
       (check-bec "(<= -3 -2)" "(true)")
       (check-bec "(<= -3 -3)" "(true)")
       (check-bec "(<= 0 0)" "(true)")
       (check-bec "(<= -1 1)" "(true)")
       (check-bec "(<= 1 -1)" "(false)")
       (check-bec "(<= 1 0)" "(false)")
       (check-bec "(<= 0 1)" "(true)")
       (check-bec "(lambda (x::(subrange 1 3)) (+ x 1))"
                  "(false true false true true false false false true)")
       (check-bec "(lambda (x::(subrange 1 3) y::bool) (if y (+ x 1) (- x 1)))"
                  "(false false false true false false false true false false true false true true false false false true)")
       (check-bec "((lambda (x::(subrange 1 4)) (+ x 1)) 4)" "(true false true)")
       (check-bec "((lambda (x::(subrange 1 4)) (+ x 1)) 2)" "(true true false)")
       (check-bec "(mk-array (x::(subrange 1 4)) (+ x 1))[4]" "(true false true)")
       (check-bec "(mk-array (x::(subrange 1 4)) (+ x 1))[2]" "(true true false)")
       (check-bec "(update (mk-tuple true 2 false) .2 10)" "(true false true false true false)")
       (check-bec "(update (mk-tuple true 2 false) .3 true)" "(true false true true)")
       (check-bec "(update (mk-tuple true 2 false) .1 false)" "(false false true false)")
       (check-bec "(update (mk-tuple 0 0 0) .1 0)" "()")
       (check-bec "(update (mk-tuple 0 0 0) .1 1)" "(true)")
       (check-bec "(update (mk-tuple 1 2 3) .1 15)" "(true true true true false true true true)")
       (check-bec "(update (mk-tuple 1 2 3) .1 0)" "(false false true true true)")
       (check-bec "(update (mk-record idx::5 flag::true) .idx 0)" "(true false false false)")
       (check-bec "(update (mk-record idx::5 flag::true) .flag false)" "(false true false true)")
       (check-bec "(update (mk-array (x::(subrange 1 4)) (+ x 1)) [1] 0)" "(false false false true true false false false true true false true)")
       (check-bec "(update (mk-array (x::(subrange 1 4)) (+ x 1)) [3] 0)" "(false true false true true false false false false true false true)")
       (check-bec "(update (mk-array (x::(subrange 1 4)) 0) [3] 0)" "()")
       (check-bec "(update (mk-array (x::(subrange 1 4)) 0) [3] 3)" "(false false false false true true false false)")
       (check-bec "(@ empty-msg data)" "(false true false false false false)")
       (check-bec "((@ msg1 data) 8)" "(false false false false false true)")
       (check-bec "((@ msg1 data) 0)" "(false false false false false false)")
       (check-bec "((@ msg1 data) 7)" "(false false true true true false)")
       (check-bec "((@ msg2 data) true false)" "(true false true false false false)")
       (check-bec "((@ msg2 data) true true)" "(true false true true false false)")
       (check-bec "((@ msg2 data) false false)" "(true false false false false false)")
       (check-bec "((@ empty-msg? data) (@ empty-msg data))" "(true)")
       (check-bec "((@ msg1? data) (@ empty-msg data))" "(false)")
       (check-bec "((@ msg2? data) (@ empty-msg data))" "(false)")
       (check-bec "((@ empty-msg? data) ((@ msg1 data) 8))" "(false)")
       (check-bec "((@ msg1? data) ((@ msg1 data) 8))" "(true)")
       (check-bec "((@ msg2? data) ((@ msg1 data) 8))" "(false)")
       (check-bec "((@ empty-msg? data) ((@ msg2 data) true true))" "(false)")
       (check-bec "((@ msg1? data) ((@ msg2 data) true true))" "(false)")
       (check-bec "((@ msg2? data) ((@ msg2 data) true true))" "(true)")
       (check-bec "((@ id data) ((@ msg1 data) 7))" "(true true true false)")
       (check-bec "((@ id data) ((@ msg1 data) 8))" "(false false false true)")
       (check-bec "((@ id data) ((@ msg1 data) 0))" "(false false false false)")
       (check-bec "((@ val1 data) ((@ msg2 data) true false))" "(true)")
       (check-bec "((@ val2 data) ((@ msg2 data) true false))" "(false)")
       (check-bec "((@ val1 data) ((@ msg2 data) false true))" "(false)")
       (check-bec "((@ val2 data) ((@ msg2 data) false true))" "(true)")
       )

(check "previous bugs"
       (check-item "pull-let bug"
                   (let* ((e1 (sal/expr "(and (let ((x::nat 1)) (> x 10)) (let ((x::nat 1)) (< x 10)))"))
                          (e2 (sal-ast/rename-variables-with-new-names (sal-ast/pull-let-decls e1)))
                          (var-names (sal-ast/fold (lambda (var-names ast)
                                                     (if (and (instance-of? ast <sal-name-expr>) (not (sal-name-ref/builtin? ast)))
                                                       (adjoin (sal-name-ref/name ast) var-names)
                                                       var-names))
                                                   '()
                                                   e2)))
                     (= (length var-names) 1)))
       (check-item "simplify if-then-else bug"
                   (not (sal-expr/true? (sal-ast/simplify (sal/expr "(if x y true)"))))))
                     

(define (check/bit-list-value-core expr-str)
  (let ((expr (sal/expr expr-str)))
    (multiple-value-bind
        (bit-list expr-type)
        (sal-expr->boolean-expr-core expr (make-empty-env) (make-queue))
      (let* ((new-bit-list (map sal-ast/simplify bit-list))
             (result-expr (bit-list->sal-value expr-type new-bit-list)))
;         (sal/pp expr)
;         (print "\n---------")
;         (sal/pp expr-type)
;         (print "\n---------")
;         (sal/pp result-expr)
;         (print "\n---------")
        (eq? (sal-expr/equal-values? expr result-expr (make-empty-env)) #t)))))
       
(define (check/bit-list-value expr)
  (check-item (string-append "bit-list-value(" expr ")")
              (check/bit-list-value-core expr)))

(sal/import "data")
(check "expr -> bit-list -> expr"
       (check/bit-list-value "10")
       (check/bit-list-value "0")
       (check/bit-list-value "-1")
       (check/bit-list-value "1")
       (check/bit-list-value "-2")
       (check/bit-list-value "12")
       (check/bit-list-value "-12")
       (check/bit-list-value "true")
       (check/bit-list-value "false")
       (check/bit-list-value "(@ trying mutex)")
       (check/bit-list-value "(@ sleeping mutex)")
       (check/bit-list-value "(@ critical mutex)")
       (check/bit-list-value "(mk-tuple 1 true 10)")
       (check/bit-list-value "(mk-tuple 0 0)")
       (check/bit-list-value "(mk-tuple 0 0 0)")
       (check/bit-list-value "(mk-tuple -10 20)")
       (check/bit-list-value "(mk-tuple (mk-tuple 10 20) 30)")
       (check/bit-list-value "(mk-record idx::10 flag::true value::0)")
       (check/bit-list-value "(mk-record idx::0 flag::0)")
       (check/bit-list-value "(lambda (x::(subrange 1 2) y::bool) (if y (+ x 1) (- x 1)))")
       (check/bit-list-value "(lambda (x::bool) x)")
       (check/bit-list-value "(lambda (x::bool y::bool) (and x y))")
       (check/bit-list-value "(mk-array (x::(subrange 1 2)) (+ x 1))")
       (check/bit-list-value "(mk-array (x::(subrange 1 4)) (* x 2))")
       (check/bit-list-value "(msg1 10)")
       (check/bit-list-value "empty-msg")
       (check/bit-list-value "(msg2 true false)")
       (check/bit-list-value "(msg2 false false)")
       (check/bit-list-value "(msg1 0)")
       )

(define (value-idx type-str expr-str)
  (sal-type/value-idx (sal/type type-str) (sal/expr expr-str)))

(define (check-valid-idx type-str expr-str expected-result)
  (check-item (string-append "value-idx(" type-str ", " expr-str ") = " (object->string expected-result))
              (eq? (value-idx type-str expr-str) expected-result)))

(check "value index"
       (check-valid-idx "bool" "true" 1)
       (check-valid-idx "bool" "false" 0)
       (check-valid-idx "(tuple bool bool)" "(mk-tuple false true)" 2)
       (check-valid-idx "(tuple bool bool)" "(mk-tuple false false)" 0)
       (check-valid-idx "(tuple bool bool)" "(mk-tuple true true)" 3)
       (check-valid-idx "nat" "3" #f)
       (check-valid-idx "(subrange 3 10)" "3" 0)
       (check-valid-idx "(subrange 3 10)" "5" 2)
       (check-valid-idx "(subrange 3 10)" "10" 7))


(define (membership type-str expr-str expected-result)
  (let ((value (sal-expr/evaluate (sal-type/finite-rep-membership-expr (sal/type type-str) (make-empty-env) (sal/expr expr-str)))))
;     (print "expr-str =")
;     (sal/pp expr-str)
;     (print "\n----------")
;     (print "value = ")
;     (sal/pp value)
;     (print "\n----------")
    (sal-ast/equivalent? value (sal/expr expected-result))))

(define (check-membership type-str expr-str expected-result)
  (check-item (string-append "membership(" type-str ", " expr-str ") = " expected-result)
              (membership type-str expr-str expected-result)))

(sal/import "data")
(check "finite type representation membership"
       (check-membership "(subrange 1 10)" "3" "true")
       (check-membership "(subrange 1 10)" "11" "false")
       (check-membership "(subrange -10 10)" "0" "true")
       (check-membership "(subrange -10 10)" "-10" "true")
       (check-membership "(subrange -10 10)" "-12" "false")
       (check-membership "(subrange -10 10)" "12" "false")
       (check-membership "(@ PC mutex)" "(@ trying mutex)" "true")
       (check-membership "(tuple bool (subrange 1 3))" "(mk-tuple false 2)" "true")
       (check-membership "(tuple bool (subrange 1 3))" "(mk-tuple false 0)" "false")
       (check-membership "(record idx::(subrange 0 2) flag::bool)" "(mk-record idx::2 flag::false)" "true")
       (check-membership "(record idx::(subrange 0 2) flag::bool)" "(mk-record idx::3 flag::false)" "false")
       (check-membership "(array bool (subrange 1 4))" "(mk-array (idx::bool) 3)" "true")
       (check-membership "(array bool (subrange 1 4))" "(mk-array (idx::bool) 5)" "false")
       (check-membership "msg" "(msg1 3)" "true")
       (check-membership "msg" "(msg1 10)" "true")
       (check-membership "msg" "(msg1 11)" "false")
       (check-membership "msg" "(msg2 true false)" "true"))

(define (check-transformation-seq-core module-str)
  (let* ((m1 (sal/module module-str))
         (m2 (sal-ast/flat-modules m1))
         (m3 (sal-ast/cse m2))
         (m4 (sal-ast/expand m3))
         (m5 (sal-ast/expand-quantifiers m4))
         (m6 (sal-ast/pull-let-decls m5))
         (m7 (sal-ast/cse m6))
         (m8 (sal-ast->boolean-ast m7))
         (m9 (sal-ast/simplify m8)))
    m9))

(define (check-transformation-seq module-str)
  (check-item (string-append "transforming " module-str)
              (check-transformation-seq-core module-str)))

(check "check transformation sequence"
       (check-transformation-seq "(@ system mutex)")
       (check-transformation-seq "(@ system four-slot)")
       (check-transformation-seq "(@ arbiter (arbiter () (10)))")
       (check-transformation-seq "(@ system pathfinder)")
       (check-transformation-seq "(@ tst-system tst-pcp-generic)"))

