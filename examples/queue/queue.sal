queue: CONTEXT =
BEGIN
  optype: TYPE = {pop, push, noop};
  Data: TYPE;

  c0: ARRAY NATURAL OF Data;

  Q: MODULE =
  BEGIN
	  INPUT op : optype
    INPUT data : Data
    LOCAL contents : ARRAY NATURAL OF Data
    LOCAL head : NATURAL
    LOCAL tail : NATURAL
    OUTPUT first : Data
    DEFINITION
      first = contents[head]
    INITIALIZATION
      head = 0;
      tail = 0; 
      contents = c0
    TRANSITION
      head' = IF op = pop THEN head + 1 ELSE head ENDIF;
      tail' = IF op = push THEN tail + 1 ELSE tail ENDIF;
      contents' = IF op = push 
                  THEN (contents WITH [tail] := data) %% update the contents, if op=push
                  ELSE contents ENDIF                 %% otherwise maintains the current value
  END;
  
  d0: Data;
  d1: Data;
  d2: Data;
  dummy: Data;
  num_steps: NATURAL = 6;

  op_seq : ARRAY NATURAL OF optype =
    [ [i : NATURAL]
      IF i <= 2 THEN push    %% three pushes 
      ELSIF i <= 5 THEN pop  %% followed by three pops
      ELSE noop ENDIF ];     %% send noop (no operation)  
   
  data_seq : ARRAY NATURAL OF Data =
    [ [i : NATURAL] 
      IF i = 0    THEN d0  %% send d0 in the first step
      ELSIF i = 1 THEN d1  %% send d1 in the second step
      ELSIF i = 2 THEN d2  %% send d2 in the third step
      ELSE dummy ENDIF];   %% otherwise send dummy
    

  test_bench1: MODULE =
  BEGIN
    OUTPUT op : optype
    OUTPUT data : Data
    INPUT first : Data
    LOCAL step : NATURAL
    LOCAL first_seq : ARRAY NATURAL OF Data
    DEFINITION
      data = data_seq[step];           %% data to be send in the current step
      op = op_seq[step]                %% op to execute in the current step
    INITIALIZATION
      step = 0; 
      first_seq[0] = first           %% record the head of the queue in the initial step
    TRANSITION
      step' = step + 1;
      first_seq'[step'] = first'     %% record the head of the queue in the next step
  END;

  system1: MODULE = (Q || test_bench1);

  th1: THEOREM system1
               |- G(step >= num_steps => 
                       (first_seq[3] = d0 AND
                        first_seq[4] = d1 AND
                        first_seq[5] = d2));

  th2: THEOREM system1 |- G(head <= tail);

  invalid: THEOREM system1
                   |- G(step >= num_steps => 
                         (first_seq[3] = d2 AND
                          first_seq[4] = d1 AND
                          first_seq[5] = d0));

END
